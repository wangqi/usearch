commit a4557ae7df5dc3ca58a4d51c9b3a0c27c386acdc
Merge: f5e597e 0a3cdc9
Author: wangqi <wang.qi@qikuyx.com>
Date:   Wed Jan 14 10:00:33 2026 -0500

    Merge remote-tracking branch 'refs/remotes/origin/main'

commit f5e597eeb9e1aca33a8bc4b71a570a95e5e7c3d6
Author: wangqi <wang.qi@qikuyx.com>
Date:   Wed Jan 14 09:59:51 2026 -0500

    Update simsimd submodule to upstream v2.23.0 version

diff --git a/simsimd b/simsimd
index 3e18990..25eacdc 160000
--- a/simsimd
+++ b/simsimd
@@ -1 +1 @@
-Subproject commit 3e18990b79bd09aeb4a28fa1972f2d069bd47fdf
+Subproject commit 25eacdc6bc541d0e04411de4b5ea06709136fc1a

commit 50ff651a903d94616ee4c0a7d3551c36165c325e
Merge: 3f9d408 7306bb4
Author: wangqi <wang.qi@qikuyx.com>
Date:   Wed Jan 14 09:58:04 2026 -0500

    Merge tag 'v2.23.0'
    
    Release: v2.23.0 [skip ci]
    
    - Add: Python 3.14 support (#693) (43ee8b7)

commit 0a3cdc9da7cff77a693861588438f2b4a7dc8ba8
Merge: 3f9d408 7306bb4
Author: Wang Qi <wangqi@users.noreply.github.com>
Date:   Wed Jan 14 09:52:47 2026 -0500

    Merge branch 'unum-cloud:main' into main

commit 7306bb446be5f0f0c529ec8acdc57361cef8a8a7
Author: TinySemVer <tinysemver@ashvardanian.com>
Date:   Tue Jan 6 01:30:29 2026 +0000

    Release: v2.23.0 [skip ci]
    ### Minor
    
    - Add: Python 3.14 support (#693) (43ee8b7)

diff --git a/CITATION.cff b/CITATION.cff
index 7881407..af1944a 100644
--- a/CITATION.cff
+++ b/CITATION.cff
@@ -5,7 +5,7 @@ authors:
     given-names: "Ash"
     orcid: "https://orcid.org/0000-0002-4882-1815"
 title: "USearch by Unum Cloud"
-version: 2.22.0
+version: 2.23.0
 doi: 10.5281/zenodo.7949416
 date-released: 2023-10-22
 url: "https://github.com/unum-cloud/usearch"
diff --git a/CMakeLists.txt b/CMakeLists.txt
index d14903f..8cfca78 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -3,7 +3,7 @@
 cmake_minimum_required(VERSION 3.11 FATAL_ERROR)
 project(
     usearch
-    VERSION 2.22.0
+    VERSION 2.23.0
     LANGUAGES C CXX
     DESCRIPTION "Smaller & Faster Single-File Vector Search Engine from Unum"
     HOMEPAGE_URL "https://github.com/unum-cloud/usearch"
diff --git a/Cargo.lock b/Cargo.lock
index 215b91e..33cf17b 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -364,7 +364,7 @@ checksum = "4a1a07cc7db3810833284e8d372ccdc6da29741639ecc70c9ec107df0fa6154c"
 
 [[package]]
 name = "usearch"
-version = "2.22.0"
+version = "2.23.0"
 dependencies = [
  "cxx",
  "cxx-build",
diff --git a/Cargo.toml b/Cargo.toml
index fb9fa24..cd95415 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -1,6 +1,6 @@
 [package]
 name = "usearch"
-version = "2.22.0"
+version = "2.23.0"
 authors = ["Ash Vardanian <1983160+ashvardanian@users.noreply.github.com>"]
 description = "Smaller & Faster Single-File Vector Search Engine from Unum"
 edition = "2021"
diff --git a/README.md b/README.md
index 4d4c396..242d66e 100644
--- a/README.md
+++ b/README.md
@@ -552,7 +552,7 @@ doi = {10.5281/zenodo.7949416},
 author = {Vardanian, Ash},
 title = {{USearch by Unum Cloud}},
 url = {https://github.com/unum-cloud/usearch},
-version = {2.22.0},
+version = {2.23.0},
 year = {2023},
 month = oct,
 }
diff --git a/VERSION b/VERSION
index f48f82f..e9763f6 100644
--- a/VERSION
+++ b/VERSION
@@ -1 +1 @@
-2.22.0
+2.23.0
diff --git a/conanfile.py b/conanfile.py
index a34fed3..74ebbe3 100644
--- a/conanfile.py
+++ b/conanfile.py
@@ -7,7 +7,7 @@ required_conan_version = ">=1.53.0"
 class USearchConan(ConanFile):
 
     name = "usearch"
-    version = "2.22.0"
+    version = "2.23.0"
     license = "Apache-2.0"
     description = "Smaller & Faster Single-File Vector Search Engine from Unum"
     homepage = "https://github.com/unum-cloud/usearch"
diff --git a/csharp/nuget/nuget-package.props b/csharp/nuget/nuget-package.props
index cb9aa78..d90e4b6 100644
--- a/csharp/nuget/nuget-package.props
+++ b/csharp/nuget/nuget-package.props
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Project>
   <PropertyGroup>
-    <Version Condition="'$(Version)' == ''">2.22.0</Version>
+    <Version Condition="'$(Version)' == ''">2.23.0</Version>
 
     <Authors>Unum</Authors>
     <Company>Unum</Company>
diff --git a/include/usearch/index.hpp b/include/usearch/index.hpp
index a14acb9..93e19e1 100644
--- a/include/usearch/index.hpp
+++ b/include/usearch/index.hpp
@@ -8,7 +8,7 @@
 #define UNUM_USEARCH_HPP
 
 #define USEARCH_VERSION_MAJOR 2
-#define USEARCH_VERSION_MINOR 22
+#define USEARCH_VERSION_MINOR 23
 #define USEARCH_VERSION_PATCH 0
 
 // Inferring C++ version
diff --git a/java/README.md b/java/README.md
index c6ce642..1df4193 100644
--- a/java/README.md
+++ b/java/README.md
@@ -19,7 +19,7 @@ repositories {
 // Task to download USearch JAR from GitHub releases
 task downloadUSearchJar {
     doLast {
-        def usearchVersion = '2.22.0'
+        def usearchVersion = '2.23.0'
         def usearchUrl = "https://github.com/unum-cloud/usearch/releases/download/v${usearchVersion}/usearch-${usearchVersion}.jar"
         def usearchFile = file("lib/usearch-${usearchVersion}.jar")
         
@@ -38,7 +38,7 @@ compileJava.dependsOn downloadUSearchJar
 
 dependencies {
     // USearch JAR from local lib directory (downloaded automatically)
-    implementation name: 'usearch', version: '2.22.0', ext: 'jar'
+    implementation name: 'usearch', version: '2.23.0', ext: 'jar'
 }
 ```
 
diff --git a/package-lock.json b/package-lock.json
index 2c317e8..0d5a4eb 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -1,6 +1,6 @@
 {
     "name": "usearch",
-    "version": "2.22.0",
+    "version": "2.23.0",
     "lockfileVersion": 3,
     "requires": true,
     "packages": {
diff --git a/package.json b/package.json
index 51067ed..5e0841e 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
     "name": "usearch",
-    "version": "2.22.0",
+    "version": "2.23.0",
     "description": "Smaller & Faster Single-File Vector Search Engine from Unum",
     "author": "Ash Vardanian (https://ashvardanian.com/)",
     "license": "Apache 2.0",
diff --git a/wasmer.toml b/wasmer.toml
index 6f92dd3..d764851 100644
--- a/wasmer.toml
+++ b/wasmer.toml
@@ -1,6 +1,6 @@
 [package]
 name = "unum/usearch"
-version = "2.22.0"
+version = "2.23.0"
 description = "Smaller & Faster Single-File Vector Search Engine from Unum"
 license = "Apache-2.0"
 readme = "README.md"

commit 43ee8b73a8ce29cc8d1e5ecfa262a655ca19111d
Author: Yurii Rashkovskii <yrashk@gmail.com>
Date:   Mon Jan 5 16:07:21 2026 -0800

    Add: Python 3.14 support (#693)

diff --git a/.github/workflows/prerelease.yml b/.github/workflows/prerelease.yml
index 759f3a3..4c92c11 100644
--- a/.github/workflows/prerelease.yml
+++ b/.github/workflows/prerelease.yml
@@ -435,7 +435,7 @@ jobs:
     strategy:
       matrix:
         os: [ubuntu-24.04, macos-14, windows-2022]
-        python-version: ["38", "39", "310", "311", "312", "313", "313t"]
+        python-version: ["38", "39", "310", "311", "312", "313", "313t", "314", "314t"]
     steps:
       - name: Checkout
         uses: actions/checkout@v6
diff --git a/.github/workflows/release.yml b/.github/workflows/release.yml
index f2547e1..592d6b2 100644
--- a/.github/workflows/release.yml
+++ b/.github/workflows/release.yml
@@ -734,7 +734,7 @@ jobs:
     strategy:
       matrix:
         os: [ubuntu-24.04, macos-14, windows-2022]
-        python-version: ["38", "39", "310", "311", "312", "313", "313t"]
+        python-version: ["38", "39", "310", "311", "312", "313", "313t", "314", "314t"]
     steps:
       - name: Check out refreshed version
         uses: actions/checkout@v6
diff --git a/pyproject.toml b/pyproject.toml
index f3855f2..bdbf2ad 100644
--- a/pyproject.toml
+++ b/pyproject.toml
@@ -3,7 +3,7 @@
 #   - `macos` wheels for x86_64, arm64, and universal2;
 #   - `windows` wheels for AMD64, and ARM64. But not x86.
 #   - `manylinux` and `musllinux` wheels for Linux on x86_64, aarch64. But not i686, ppc64le, s390x;
-#   * for CPython versions from 3.7 to 3.13.
+#   * for CPython versions from 3.7 to 3.14.
 #   * for PyPy versions from 3.7 to 3.10.
 #   = meaning 7 platforms * 11 Python versions = 77 builds.
 [build-system]
@@ -90,4 +90,4 @@ before-build = [
 # https://black.readthedocs.io/en/latest/usage_and_configuration/the_basics.html#where-black-looks-for-the-file
 [tool.black]
 line-length = 120                  # Set line length to the same value as in `.clang-format` for modern wide screens
-target-version = ['py36', 'py313']
+target-version = ['py36', 'py314']

commit 5fd2d3a7d340cc93b1de2b47d489d27e9dfe4958
Author: TinySemVer <tinysemver@ashvardanian.com>
Date:   Sun Dec 21 19:16:09 2025 +0000

    Release: v2.22.0 [skip ci]
    ### Minor
    
    - Add: Missing GoLang APIs (3590961)
    - Add: FilteredSearch and FilteredSearchI8 functions (1f3e086)
    - Add: Nil handler validation in FilteredSearchUnsafe (0df8511)
    - Add: Filtered search callback support in GoLang bindings (4829a29)
    
    ### Patch
    
    - Fix: Consistent threads capacity in Go tests (cc86de9)
    - Make: Bump SimSIMD (42aef88)
    - Fix: Missing `switch` cases for settings (6e84b1f)
    - Fix: Keep GoLang vectors alive (ba7d699)
    - Improve: Make FilteredSearchHandler fields public (55c1ea8)
    - Fix: FilteredSearchHandler typo and use correct C function (3cd62ce)
    - Improve: Add data field to FilteredSearchHandler test (a17c6fa)
    - Fix: Filtered search test logic and remove debug output (95f713e)
    - Improve: FilteredSearchUnsafe documentation (72a9f5a)
    - Improve: Fewer conditional locks for immutable index views (#689) (4f02166)
    - Fix: static is not thread safe (8938d6e)
    - Fix: check maxResults > 0 (f109269)
    - Fix: exact search return results with size querySize * maxResults (c8adc05)
    - Make: Bump CI versions (7685a67)
    - Make: Wrong ISA extensions for Windows JNI builds (42ff470)

diff --git a/CITATION.cff b/CITATION.cff
index e72352d..7881407 100644
--- a/CITATION.cff
+++ b/CITATION.cff
@@ -5,7 +5,7 @@ authors:
     given-names: "Ash"
     orcid: "https://orcid.org/0000-0002-4882-1815"
 title: "USearch by Unum Cloud"
-version: 2.21.4
+version: 2.22.0
 doi: 10.5281/zenodo.7949416
 date-released: 2023-10-22
 url: "https://github.com/unum-cloud/usearch"
diff --git a/CMakeLists.txt b/CMakeLists.txt
index c3abac4..d14903f 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -3,7 +3,7 @@
 cmake_minimum_required(VERSION 3.11 FATAL_ERROR)
 project(
     usearch
-    VERSION 2.21.4
+    VERSION 2.22.0
     LANGUAGES C CXX
     DESCRIPTION "Smaller & Faster Single-File Vector Search Engine from Unum"
     HOMEPAGE_URL "https://github.com/unum-cloud/usearch"
diff --git a/Cargo.lock b/Cargo.lock
index c13971a..215b91e 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -364,7 +364,7 @@ checksum = "4a1a07cc7db3810833284e8d372ccdc6da29741639ecc70c9ec107df0fa6154c"
 
 [[package]]
 name = "usearch"
-version = "2.21.4"
+version = "2.22.0"
 dependencies = [
  "cxx",
  "cxx-build",
diff --git a/Cargo.toml b/Cargo.toml
index d288394..fb9fa24 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -1,6 +1,6 @@
 [package]
 name = "usearch"
-version = "2.21.4"
+version = "2.22.0"
 authors = ["Ash Vardanian <1983160+ashvardanian@users.noreply.github.com>"]
 description = "Smaller & Faster Single-File Vector Search Engine from Unum"
 edition = "2021"
diff --git a/README.md b/README.md
index 93a178d..4d4c396 100644
--- a/README.md
+++ b/README.md
@@ -552,7 +552,7 @@ doi = {10.5281/zenodo.7949416},
 author = {Vardanian, Ash},
 title = {{USearch by Unum Cloud}},
 url = {https://github.com/unum-cloud/usearch},
-version = {2.21.4},
+version = {2.22.0},
 year = {2023},
 month = oct,
 }
diff --git a/VERSION b/VERSION
index 2aed618..f48f82f 100644
--- a/VERSION
+++ b/VERSION
@@ -1 +1 @@
-2.21.4
+2.22.0
diff --git a/conanfile.py b/conanfile.py
index 798b9e8..a34fed3 100644
--- a/conanfile.py
+++ b/conanfile.py
@@ -7,7 +7,7 @@ required_conan_version = ">=1.53.0"
 class USearchConan(ConanFile):
 
     name = "usearch"
-    version = "2.21.4"
+    version = "2.22.0"
     license = "Apache-2.0"
     description = "Smaller & Faster Single-File Vector Search Engine from Unum"
     homepage = "https://github.com/unum-cloud/usearch"
diff --git a/csharp/nuget/nuget-package.props b/csharp/nuget/nuget-package.props
index 62f17fb..cb9aa78 100644
--- a/csharp/nuget/nuget-package.props
+++ b/csharp/nuget/nuget-package.props
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Project>
   <PropertyGroup>
-    <Version Condition="'$(Version)' == ''">2.21.4</Version>
+    <Version Condition="'$(Version)' == ''">2.22.0</Version>
 
     <Authors>Unum</Authors>
     <Company>Unum</Company>
diff --git a/include/usearch/index.hpp b/include/usearch/index.hpp
index bdbd2ae..a14acb9 100644
--- a/include/usearch/index.hpp
+++ b/include/usearch/index.hpp
@@ -8,8 +8,8 @@
 #define UNUM_USEARCH_HPP
 
 #define USEARCH_VERSION_MAJOR 2
-#define USEARCH_VERSION_MINOR 21
-#define USEARCH_VERSION_PATCH 4
+#define USEARCH_VERSION_MINOR 22
+#define USEARCH_VERSION_PATCH 0
 
 // Inferring C++ version
 // https://stackoverflow.com/a/61552074
diff --git a/java/README.md b/java/README.md
index 1f3cad1..c6ce642 100644
--- a/java/README.md
+++ b/java/README.md
@@ -19,7 +19,7 @@ repositories {
 // Task to download USearch JAR from GitHub releases
 task downloadUSearchJar {
     doLast {
-        def usearchVersion = '2.21.4'
+        def usearchVersion = '2.22.0'
         def usearchUrl = "https://github.com/unum-cloud/usearch/releases/download/v${usearchVersion}/usearch-${usearchVersion}.jar"
         def usearchFile = file("lib/usearch-${usearchVersion}.jar")
         
@@ -38,7 +38,7 @@ compileJava.dependsOn downloadUSearchJar
 
 dependencies {
     // USearch JAR from local lib directory (downloaded automatically)
-    implementation name: 'usearch', version: '2.21.4', ext: 'jar'
+    implementation name: 'usearch', version: '2.22.0', ext: 'jar'
 }
 ```
 
diff --git a/package-lock.json b/package-lock.json
index ce7e8a4..2c317e8 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -1,6 +1,6 @@
 {
     "name": "usearch",
-    "version": "2.21.4",
+    "version": "2.22.0",
     "lockfileVersion": 3,
     "requires": true,
     "packages": {
diff --git a/package.json b/package.json
index 59cb3af..51067ed 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
     "name": "usearch",
-    "version": "2.21.4",
+    "version": "2.22.0",
     "description": "Smaller & Faster Single-File Vector Search Engine from Unum",
     "author": "Ash Vardanian (https://ashvardanian.com/)",
     "license": "Apache 2.0",
diff --git a/wasmer.toml b/wasmer.toml
index c363c85..6f92dd3 100644
--- a/wasmer.toml
+++ b/wasmer.toml
@@ -1,6 +1,6 @@
 [package]
 name = "unum/usearch"
-version = "2.21.4"
+version = "2.22.0"
 description = "Smaller & Faster Single-File Vector Search Engine from Unum"
 license = "Apache-2.0"
 readme = "README.md"

commit 9f281e59535847f319d3513ab8af6278f8b10532
Merge: a2f1759 cc86de9
Author: Ash Vardanian <1983160+ashvardanian@users.noreply.github.com>
Date:   Sun Dec 21 19:16:00 2025 +0000

    Merge: GoLang, Perf, & Refreshed CI (#690)
    
    * Make: Wrong ISA extensions for Windows JNI builds
    
    * Make: Bump CI versions
    
    * Fix: exact search return results with size querySize * maxResults
    
    * Fix: check maxResults > 0
    
    * Fix: static is not thread safe
    
    * Update: add more tests
    
    * Improve: Fewer conditional locks for immutable index views (#689)
    
    Co-authored-by: Ash Vardanian <1983160+ashvardanian@users.noreply.github.com>
    
    * Add: Filtered search callback support in GoLang bindings
    
    * Improve: FilteredSearchUnsafe documentation
    
    * Fix: Filtered search test logic and remove debug output
    
    * Improve: Add data field to FilteredSearchHandler test
    
    * Add: Nil handler validation in FilteredSearchUnsafe
    
    * Add: FilteredSearch and FilteredSearchI8 functions
    
    * Fix: FilteredSearchHandler typo and use correct C function
    
    * Improve: Make FilteredSearchHandler fields public
    
    * Fix: Keep GoLang vectors alive
    
    * Fix: Missing `switch` cases for settings
    
    * Make: Bump SimSIMD
    
    * Add: Missing GoLang APIs
    
    * Fix: Consistent threads capacity in Go tests
    
    ---------
    
    Co-authored-by: cpegeric <cpegeric@gmail.com>
    Co-authored-by: Yoonseok Kim <43584573+yoonseok-kim@users.noreply.github.com>

commit cc86de97fb5d3ec1f4548725c30a21ca58d7f357
Author: Ash Vardanian <1983160+ashvardanian@users.noreply.github.com>
Date:   Sun Dec 21 18:55:28 2025 +0000

    Fix: Consistent threads capacity in Go tests

diff --git a/golang/README.md b/golang/README.md
index 1c8fed8..764641c 100644
--- a/golang/README.md
+++ b/golang/README.md
@@ -84,9 +84,7 @@ func main() {
 }
 ```
 
-Notes:
-- Always call `Reserve(capacity)` before the first write.
-- Prefer single-caller writes with internal parallelism via `ChangeThreadsAdd` and internal parallel searches via `ChangeThreadsSearch`, instead of calling `Add` concurrently.
+Always call `Reserve(capacity)` before the first write.
 
 3. Get USearch:
 
@@ -184,3 +182,32 @@ keys, distances, err := usearch.ExactSearch(
     maxResults, 0,  // 0 threads = auto-detect
 )
 ```
+
+## Concurrency
+
+USearch supports concurrent operations from multiple goroutines. Use `ChangeThreadsAdd` and `ChangeThreadsSearch` to configure the number of concurrent operations allowed:
+
+```go
+err := index.ChangeThreadsAdd(8)	// Allow up to 8 concurrent additions
+err = index.ChangeThreadsSearch(16)	// Allow up to 16 concurrent searches
+```
+
+When using multiple goroutines, reserve at least as many threads as the number of concurrent callers:
+
+```go
+const numWorkers = 10
+
+// Reserve threads for concurrent searches
+_ = index.ChangeThreadsSearch(numWorkers)
+
+var wg sync.WaitGroup
+for i := 0; i < numWorkers; i++ {
+    wg.Add(1)
+    go func() {
+        defer wg.Done()
+        keys, distances, err := index.Search(queryVector, 10)
+        // ...
+    }()
+}
+wg.Wait()
+```
diff --git a/golang/lib_test.go b/golang/lib_test.go
index cd9f354..4f9b724 100644
--- a/golang/lib_test.go
+++ b/golang/lib_test.go
@@ -1,7 +1,7 @@
 package usearch
 
 import (
-	"fmt"
+	"errors"
 	"io"
 	"math"
 	"runtime"
@@ -786,16 +786,15 @@ func TestConcurrentSearches(t *testing.T) {
 		// Pre-populate with data
 		testVectors := populateIndex(t, index, 200)
 
-		// Let the library parallelize search internally as well
-		_ = index.ChangeThreadsSearch(uint(runtime.NumCPU()))
-
 		const numGoroutines = 30
 		const searchesPerGoroutine = 50
 
+		// Reserve enough threads for all concurrent search operations
+		_ = index.ChangeThreadsSearch(numGoroutines)
+
 		var wg sync.WaitGroup
-		errorChan := make(chan error, numGoroutines)
+		errChan := make(chan error, numGoroutines)
 
-		// Only concurrent searches - no mixed operations
 		for i := 0; i < numGoroutines; i++ {
 			wg.Add(1)
 			go func(goroutineID int) {
@@ -808,19 +807,19 @@ func TestConcurrentSearches(t *testing.T) {
 
 					keys, distances, err := index.Search(query, 10)
 					if err != nil {
-						errorChan <- err
+						errChan <- err
 						return
 					}
 
 					// Basic validation - should find at least the exact match
 					if len(keys) == 0 || len(distances) == 0 {
-						errorChan <- fmt.Errorf("search returned empty results")
+						errChan <- errors.New("search returned empty results")
 						return
 					}
 
 					// First result should be the exact match
 					if keys[0] != Key(queryIndex) || math.Abs(float64(distances[0])) > distanceTolerance {
-						errorChan <- fmt.Errorf("search results inconsistent: expected key %d, got %d", queryIndex, keys[0])
+						errChan <- errors.New("search results inconsistent")
 						return
 					}
 				}
@@ -828,10 +827,10 @@ func TestConcurrentSearches(t *testing.T) {
 		}
 
 		wg.Wait()
-		close(errorChan)
+		close(errChan)
 
 		// Check for any errors
-		for err := range errorChan {
+		for err := range errChan {
 			t.Fatalf("Concurrent search failed: %v", err)
 		}
 	})

commit 35909612aa60c50b21cf06d4ab5fe0757ce0a7f1
Author: Ash Vardanian <1983160+ashvardanian@users.noreply.github.com>
Date:   Sun Dec 21 17:57:29 2025 +0000

    Add: Missing GoLang APIs

diff --git a/golang/README.md b/golang/README.md
index e52c0b3..1c8fed8 100644
--- a/golang/README.md
+++ b/golang/README.md
@@ -120,3 +120,67 @@ if err != nil {
     panic("Failed to view index")
 }
 ```
+
+## Index Introspection
+
+Inspect and interact with the index:
+
+```go
+dimensions, _ := index.Dimensions()     // Get the number of dimensions
+size, _ := index.Len()                  // Get the number of vectors
+capacity, _ := index.Capacity()         // Get the capacity
+containsKey, _ := index.Contains(42)    // Check if a key is in the index
+count, _ := index.Count(42)             // Get the count of vectors for a key (multi-vector indexes)
+version := usearch.Version()            // Get the library version string
+```
+
+## Modifying the Index
+
+```go
+// Remove a vector by key
+err := index.Remove(42)
+
+// Clear all vectors while preserving the index structure
+err = index.Clear()
+
+// Rename a key
+err = index.Rename(oldKey, newKey)
+```
+
+## Filtered Search
+
+Perform searches with custom filtering:
+
+```go
+// Define a filter callback
+handler := &usearch.FilteredSearchHandler{
+    Callback: func(key usearch.Key, handler *usearch.FilteredSearchHandler) int {
+        // Return non-zero to accept, zero to reject
+        if key % 2 == 0 {
+            return 1 // Accept even keys
+        }
+        return 0 // Reject odd keys
+    },
+    Data: nil, // Optional user data
+}
+
+// Perform filtered search
+keys, distances, err := index.FilteredSearch(queryVector, 10, handler)
+```
+
+## Exact Search
+
+For smaller datasets, perform brute-force exact search without building an index:
+
+```go
+dataset := []float32{...}  // Flattened vectors
+queries := []float32{...}  // Flattened query vectors
+
+keys, distances, err := usearch.ExactSearch(
+    dataset, queries,
+    datasetSize, queryCount,
+    vectorDims*4, vectorDims*4,  // Strides in bytes
+    vectorDims, usearch.Cosine,
+    maxResults, 0,  // 0 threads = auto-detect
+)
+```
diff --git a/golang/lib.go b/golang/lib.go
index d5f96db..1f21e00 100644
--- a/golang/lib.go
+++ b/golang/lib.go
@@ -208,7 +208,7 @@ func DefaultConfig(dimensions uint) IndexConfig {
 	return c
 }
 
-// FilteredSearchHandler include the callback functiona and user data
+// FilteredSearchHandler includes the callback function and user data.
 type FilteredSearchHandler struct {
 	Callback func(key Key, handler *FilteredSearchHandler) int
 	Data     any
@@ -246,15 +246,15 @@ func NewIndex(conf IndexConfig) (index *Index, err error) {
 	conf = index.config
 	dimensions := C.size_t(conf.Dimensions)
 	connectivity := C.size_t(conf.Connectivity)
-	expansion_add := C.size_t(conf.ExpansionAdd)
-	expansion_search := C.size_t(conf.ExpansionSearch)
+	expansionAdd := C.size_t(conf.ExpansionAdd)
+	expansionSearch := C.size_t(conf.ExpansionSearch)
 	multi := C.bool(conf.Multi)
 
 	options := C.struct_usearch_init_options_t{}
 	options.dimensions = dimensions
 	options.connectivity = connectivity
-	options.expansion_add = expansion_add
-	options.expansion_search = expansion_search
+	options.expansion_add = expansionAdd
+	options.expansion_search = expansionSearch
 	options.multi = multi
 	options.metric_kind = conf.Metric.CValue()
 
@@ -271,6 +271,11 @@ func NewIndex(conf IndexConfig) (index *Index, err error) {
 	return index, nil
 }
 
+// Version returns the USearch library version string.
+func Version() string {
+	return C.GoString(C.usearch_version())
+}
+
 // Len returns the number of vectors in the index.
 func (index *Index) Len() (len uint, err error) {
 	var errorMessage *C.char
@@ -393,13 +398,13 @@ func (index *Index) Capacity() (cap uint, err error) {
 	return cap, err
 }
 
-// HardwareAcceleration returns a string showing the SIMD capability for the index
+// HardwareAcceleration returns a string showing the SIMD capability for the index.
 func (index *Index) HardwareAcceleration() (string, error) {
 	var str *C.char
 	var errorMessage *C.char
 	str = C.usearch_hardware_acceleration(index.handle, (*C.usearch_error_t)(&errorMessage))
 	if errorMessage != nil {
-		return C.GoString(nil), errors.New(C.GoString(errorMessage))
+		return "", errors.New(C.GoString(errorMessage))
 	}
 	return C.GoString(str), nil
 }
@@ -512,6 +517,20 @@ func (index *Index) Remove(key Key) error {
 	return nil
 }
 
+// Clear removes all vectors from the index while preserving its structure.
+func (index *Index) Clear() error {
+	if index.handle == nil {
+		panic("index is uninitialized")
+	}
+
+	var errorMessage *C.char
+	C.usearch_clear(index.handle, (*C.usearch_error_t)(&errorMessage))
+	if errorMessage != nil {
+		return errors.New(C.GoString(errorMessage))
+	}
+	return nil
+}
+
 // Contains checks if the index contains a vector with a specific key.
 func (index *Index) Contains(key Key) (found bool, err error) {
 	if index.handle == nil {
@@ -526,6 +545,21 @@ func (index *Index) Contains(key Key) (found bool, err error) {
 	return found, nil
 }
 
+// Count returns the number of vectors stored under the given key.
+// Useful for multi-vector indexes where multiple vectors can share a key.
+func (index *Index) Count(key Key) (count uint, err error) {
+	if index.handle == nil {
+		panic("index is uninitialized")
+	}
+
+	var errorMessage *C.char
+	count = uint(C.usearch_count(index.handle, (C.usearch_key_t)(key), (*C.usearch_error_t)(&errorMessage)))
+	if errorMessage != nil {
+		return 0, errors.New(C.GoString(errorMessage))
+	}
+	return count, nil
+}
+
 // Get retrieves the vectors associated with the given key from the index.
 // Returns nil if the key is not found.
 func (index *Index) Get(key Key, maxCount uint) (vectors []float32, err error) {
@@ -550,7 +584,7 @@ func (index *Index) Get(key Key, maxCount uint) (vectors []float32, err error) {
 	return vectors, nil
 }
 
-// Rename the vector at key from to key to
+// Rename changes the key of a vector from one value to another.
 func (index *Index) Rename(from Key, to Key) error {
 	var errorMessage *C.char
 	C.usearch_rename(index.handle, C.usearch_key_t(from), C.usearch_key_t(to), (*C.usearch_error_t)(&errorMessage))
@@ -649,19 +683,19 @@ func (index *Index) Search(query []float32, limit uint) (keys []Key, distances [
 	return keys, distances, nil
 }
 
-// Search finds the k nearest neighbors to the query vector.
+// FilteredSearch finds the k nearest neighbors to the query vector, applying a filter.
 //
 // Parameters:
 //   - query: Must have exactly Dimensions() elements
 //   - limit: Maximum number of results to return
+//   - handler: Filter callback that returns non-zero to accept a candidate, zero to reject
 //
 // Returns:
-//   - keys: IDs of the nearest vectors (up to limit)
+//   - keys: IDs of the nearest vectors that passed the filter (up to limit)
 //   - distances: Distance to each result (same length as keys)
-//   - err: Error if query is invalid or search fails
+//   - err: Error if query is invalid, handler is nil, or search fails
 //
-// The actual number of results may be less than limit if the index
-// contains fewer vectors.
+// The actual number of results may be less than limit if fewer vectors pass the filter.
 func (index *Index) FilteredSearch(query []float32, limit uint, handler *FilteredSearchHandler) (keys []Key, distances []float32, err error) {
 	if index.handle == nil {
 		panic("index is uninitialized")
@@ -743,7 +777,13 @@ func goFilteredSearchCallback(key C.usearch_key_t, ptr unsafe.Pointer) C.int {
 	return C.int(handler.Callback(Key(key), handler))
 }
 
-// Filtred Search performs k-Approximate Nearest Neighbors Search for the closest vectors to the query vector with filtering.
+// FilteredSearchUnsafe performs filtered k-ANN search using an unsafe pointer.
+//
+// SAFETY REQUIREMENTS:
+//   - query must not be nil
+//   - Memory at query must contain exactly Dimensions() scalars
+//   - Scalar type must match index.config.Quantization
+//   - Memory must remain valid for the duration of the call
 func (index *Index) FilteredSearchUnsafe(query unsafe.Pointer, limit uint, handler *FilteredSearchHandler) (keys []Key, distances []float32, err error) {
 	if index.handle == nil {
 		panic("index is uninitialized")
@@ -1028,7 +1068,7 @@ func ExactSearchI8(dataset []int8, queries []int8, datasetSize uint, queryCount
 // SaveBuffer serializes the index into a byte buffer.
 // The buffer must be large enough to hold the serialized index.
 // Use SerializedLength() to determine the required buffer size.
-func (index *Index) SaveBuffer(buf []byte, buffer_size uint) error {
+func (index *Index) SaveBuffer(buf []byte, bufferSize uint) error {
 	if index.handle == nil {
 		panic("index is uninitialized")
 	}
@@ -1036,12 +1076,12 @@ func (index *Index) SaveBuffer(buf []byte, buffer_size uint) error {
 	if len(buf) == 0 {
 		return errors.New("buffer cannot be empty")
 	}
-	if uint(len(buf)) < buffer_size {
-		return fmt.Errorf("buffer too small: has %d bytes, need %d", len(buf), buffer_size)
+	if uint(len(buf)) < bufferSize {
+		return fmt.Errorf("buffer too small: has %d bytes, need %d", len(buf), bufferSize)
 	}
 
 	var errorMessage *C.char
-	C.usearch_save_buffer(index.handle, unsafe.Pointer(&buf[0]), C.size_t(buffer_size), (*C.usearch_error_t)(&errorMessage))
+	C.usearch_save_buffer(index.handle, unsafe.Pointer(&buf[0]), C.size_t(bufferSize), (*C.usearch_error_t)(&errorMessage))
 	runtime.KeepAlive(buf)
 	if errorMessage != nil {
 		return errors.New(C.GoString(errorMessage))
@@ -1051,7 +1091,7 @@ func (index *Index) SaveBuffer(buf []byte, buffer_size uint) error {
 
 // LoadBuffer loads a serialized index from a byte buffer.
 // The buffer must contain a valid serialized index.
-func (index *Index) LoadBuffer(buf []byte, buffer_size uint) error {
+func (index *Index) LoadBuffer(buf []byte, bufferSize uint) error {
 	if index.handle == nil {
 		panic("index is uninitialized")
 	}
@@ -1059,12 +1099,12 @@ func (index *Index) LoadBuffer(buf []byte, buffer_size uint) error {
 	if len(buf) == 0 {
 		return errors.New("buffer cannot be empty")
 	}
-	if uint(len(buf)) < buffer_size {
-		return fmt.Errorf("buffer too small: has %d bytes, need %d", len(buf), buffer_size)
+	if uint(len(buf)) < bufferSize {
+		return fmt.Errorf("buffer too small: has %d bytes, need %d", len(buf), bufferSize)
 	}
 
 	var errorMessage *C.char
-	C.usearch_load_buffer(index.handle, unsafe.Pointer(&buf[0]), C.size_t(buffer_size), (*C.usearch_error_t)(&errorMessage))
+	C.usearch_load_buffer(index.handle, unsafe.Pointer(&buf[0]), C.size_t(bufferSize), (*C.usearch_error_t)(&errorMessage))
 	runtime.KeepAlive(buf)
 	if errorMessage != nil {
 		return errors.New(C.GoString(errorMessage))
@@ -1075,7 +1115,7 @@ func (index *Index) LoadBuffer(buf []byte, buffer_size uint) error {
 // ViewBuffer creates a view of a serialized index without copying the data.
 // The buffer must remain valid for the lifetime of the index.
 // Changes to the buffer will affect the index.
-func (index *Index) ViewBuffer(buf []byte, buffer_size uint) error {
+func (index *Index) ViewBuffer(buf []byte, bufferSize uint) error {
 	if index.handle == nil {
 		panic("index is uninitialized")
 	}
@@ -1083,12 +1123,12 @@ func (index *Index) ViewBuffer(buf []byte, buffer_size uint) error {
 	if len(buf) == 0 {
 		return errors.New("buffer cannot be empty")
 	}
-	if uint(len(buf)) < buffer_size {
-		return fmt.Errorf("buffer too small: has %d bytes, need %d", len(buf), buffer_size)
+	if uint(len(buf)) < bufferSize {
+		return fmt.Errorf("buffer too small: has %d bytes, need %d", len(buf), bufferSize)
 	}
 
 	var errorMessage *C.char
-	C.usearch_view_buffer(index.handle, unsafe.Pointer(&buf[0]), C.size_t(buffer_size), (*C.usearch_error_t)(&errorMessage))
+	C.usearch_view_buffer(index.handle, unsafe.Pointer(&buf[0]), C.size_t(bufferSize), (*C.usearch_error_t)(&errorMessage))
 	runtime.KeepAlive(buf)
 	if errorMessage != nil {
 		return errors.New(C.GoString(errorMessage))
@@ -1098,19 +1138,19 @@ func (index *Index) ViewBuffer(buf []byte, buffer_size uint) error {
 
 // MetadataBuffer extracts index configuration metadata from a serialized buffer.
 // This can be used to inspect an index before loading it.
-func MetadataBuffer(buf []byte, buffer_size uint) (c IndexConfig, err error) {
+func MetadataBuffer(buf []byte, bufferSize uint) (c IndexConfig, err error) {
 	if len(buf) == 0 {
 		return c, errors.New("buffer cannot be empty")
 	}
-	if uint(len(buf)) < buffer_size {
-		return c, fmt.Errorf("buffer too small: has %d bytes, need %d", len(buf), buffer_size)
+	if uint(len(buf)) < bufferSize {
+		return c, fmt.Errorf("buffer too small: has %d bytes, need %d", len(buf), bufferSize)
 	}
 	c = IndexConfig{}
 
 	options := C.struct_usearch_init_options_t{}
 
 	var errorMessage *C.char
-	C.usearch_metadata_buffer(unsafe.Pointer(&buf[0]), C.size_t(buffer_size), &options, (*C.usearch_error_t)(&errorMessage))
+	C.usearch_metadata_buffer(unsafe.Pointer(&buf[0]), C.size_t(bufferSize), &options, (*C.usearch_error_t)(&errorMessage))
 	runtime.KeepAlive(buf)
 	if errorMessage != nil {
 		return c, errors.New(C.GoString(errorMessage))
@@ -1154,6 +1194,8 @@ func MetadataBuffer(buf []byte, buffer_size uint) (c IndexConfig, err error) {
 		c.Quantization = I8
 	case C.usearch_scalar_b1_k:
 		c.Quantization = B1
+	case C.usearch_scalar_bf16_k:
+		c.Quantization = BF16
 	}
 
 	return c, nil
@@ -1166,13 +1208,13 @@ func Metadata(path string) (c IndexConfig, err error) {
 		return c, errors.New("path cannot be empty")
 	}
 
-	c_path := C.CString(path)
-	defer C.free(unsafe.Pointer(c_path))
+	cPath := C.CString(path)
+	defer C.free(unsafe.Pointer(cPath))
 
 	options := C.struct_usearch_init_options_t{}
 
 	var errorMessage *C.char
-	C.usearch_metadata(c_path, &options, (*C.usearch_error_t)(&errorMessage))
+	C.usearch_metadata(cPath, &options, (*C.usearch_error_t)(&errorMessage))
 	if errorMessage != nil {
 		return c, errors.New(C.GoString(errorMessage))
 	}
@@ -1228,11 +1270,11 @@ func (index *Index) Save(path string) error {
 		panic("index is uninitialized")
 	}
 
-	c_path := C.CString(path)
-	defer C.free(unsafe.Pointer(c_path))
+	cPath := C.CString(path)
+	defer C.free(unsafe.Pointer(cPath))
 
 	var errorMessage *C.char
-	C.usearch_save((C.usearch_index_t)(unsafe.Pointer(index.handle)), c_path, (*C.usearch_error_t)(&errorMessage))
+	C.usearch_save(index.handle, cPath, (*C.usearch_error_t)(&errorMessage))
 	if errorMessage != nil {
 		return errors.New(C.GoString(errorMessage))
 	}
@@ -1245,11 +1287,11 @@ func (index *Index) Load(path string) error {
 		panic("index is uninitialized")
 	}
 
-	c_path := C.CString(path)
-	defer C.free(unsafe.Pointer(c_path))
+	cPath := C.CString(path)
+	defer C.free(unsafe.Pointer(cPath))
 
 	var errorMessage *C.char
-	C.usearch_load((C.usearch_index_t)(unsafe.Pointer(index.handle)), c_path, (*C.usearch_error_t)(&errorMessage))
+	C.usearch_load(index.handle, cPath, (*C.usearch_error_t)(&errorMessage))
 	if errorMessage != nil {
 		return errors.New(C.GoString(errorMessage))
 	}
@@ -1262,11 +1304,11 @@ func (index *Index) View(path string) error {
 		panic("index is uninitialized")
 	}
 
-	c_path := C.CString(path)
-	defer C.free(unsafe.Pointer(c_path))
+	cPath := C.CString(path)
+	defer C.free(unsafe.Pointer(cPath))
 
 	var errorMessage *C.char
-	C.usearch_view((C.usearch_index_t)(unsafe.Pointer(index.handle)), c_path, (*C.usearch_error_t)(&errorMessage))
+	C.usearch_view(index.handle, cPath, (*C.usearch_error_t)(&errorMessage))
 	if errorMessage != nil {
 		return errors.New(C.GoString(errorMessage))
 	}
diff --git a/golang/lib_test.go b/golang/lib_test.go
index 34e28ca..cd9f354 100644
--- a/golang/lib_test.go
+++ b/golang/lib_test.go
@@ -982,9 +982,6 @@ func TestExactSearch(t *testing.T) {
 				len(keys), len(distances))
 		}
 
-		fmt.Printf("keys %v\n", keys)
-		fmt.Printf("distances %v\n", distances)
-
 		for i := 0; i < querySize; i++ {
 			if keys[i] != Key(i) || distances[i] != 0 {
 				t.Fatalf("Expected same results from ExactSearch for all keys and distances")
@@ -1037,3 +1034,144 @@ func TestDistanceCalculations(t *testing.T) {
 		}
 	})
 }
+
+func TestVersion(t *testing.T) {
+	version := Version()
+	if version == "" {
+		t.Fatal("Version() returned empty string")
+	}
+	// Version should be in format like "2.21.4"
+	if len(version) < 5 {
+		t.Fatalf("Version() returned unexpectedly short string: %s", version)
+	}
+}
+
+func TestClear(t *testing.T) {
+	index := createTestIndex(t, 32, F32)
+	defer index.Destroy()
+
+	if err := index.Reserve(10); err != nil {
+		t.Fatalf("Failed to reserve capacity: %v", err)
+	}
+
+	// Add some vectors
+	for i := 0; i < 5; i++ {
+		vector := generateTestVector(32)
+		vector[0] = float32(i)
+		if err := index.Add(Key(i), vector); err != nil {
+			t.Fatalf("Failed to add vector %d: %v", i, err)
+		}
+	}
+
+	// Verify vectors were added
+	size, err := index.Len()
+	if err != nil {
+		t.Fatalf("Failed to get index size: %v", err)
+	}
+	if size != 5 {
+		t.Fatalf("Expected 5 vectors, got %d", size)
+	}
+
+	// Clear the index
+	if err := index.Clear(); err != nil {
+		t.Fatalf("Failed to clear index: %v", err)
+	}
+
+	// Verify index is empty
+	size, err = index.Len()
+	if err != nil {
+		t.Fatalf("Failed to get index size after clear: %v", err)
+	}
+	if size != 0 {
+		t.Fatalf("Expected 0 vectors after clear, got %d", size)
+	}
+}
+
+func TestCount(t *testing.T) {
+	index := createTestIndex(t, 32, F32)
+	defer index.Destroy()
+
+	if err := index.Reserve(10); err != nil {
+		t.Fatalf("Failed to reserve capacity: %v", err)
+	}
+
+	// Count for non-existent key should be 0
+	count, err := index.Count(Key(42))
+	if err != nil {
+		t.Fatalf("Failed to count key: %v", err)
+	}
+	if count != 0 {
+		t.Fatalf("Expected count 0 for non-existent key, got %d", count)
+	}
+
+	// Add a vector
+	vector := generateTestVector(32)
+	if err := index.Add(Key(42), vector); err != nil {
+		t.Fatalf("Failed to add vector: %v", err)
+	}
+
+	// Count should now be 1
+	count, err = index.Count(Key(42))
+	if err != nil {
+		t.Fatalf("Failed to count key after add: %v", err)
+	}
+	if count != 1 {
+		t.Fatalf("Expected count 1 after add, got %d", count)
+	}
+}
+
+func TestRename(t *testing.T) {
+	index := createTestIndex(t, 32, F32)
+	defer index.Destroy()
+
+	if err := index.Reserve(10); err != nil {
+		t.Fatalf("Failed to reserve capacity: %v", err)
+	}
+
+	// Add a vector with key 1
+	vector := generateTestVector(32)
+	if err := index.Add(Key(1), vector); err != nil {
+		t.Fatalf("Failed to add vector: %v", err)
+	}
+
+	// Verify key 1 exists
+	found, err := index.Contains(Key(1))
+	if err != nil {
+		t.Fatalf("Failed to check contains: %v", err)
+	}
+	if !found {
+		t.Fatal("Key 1 should exist before rename")
+	}
+
+	// Rename key 1 to key 2
+	if err := index.Rename(Key(1), Key(2)); err != nil {
+		t.Fatalf("Failed to rename key: %v", err)
+	}
+
+	// Verify key 1 no longer exists
+	found, err = index.Contains(Key(1))
+	if err != nil {
+		t.Fatalf("Failed to check contains after rename: %v", err)
+	}
+	if found {
+		t.Fatal("Key 1 should not exist after rename")
+	}
+
+	// Verify key 2 now exists
+	found, err = index.Contains(Key(2))
+	if err != nil {
+		t.Fatalf("Failed to check contains for new key: %v", err)
+	}
+	if !found {
+		t.Fatal("Key 2 should exist after rename")
+	}
+
+	// Verify we can search and find the renamed vector
+	keys, _, err := index.Search(vector, 1)
+	if err != nil {
+		t.Fatalf("Failed to search: %v", err)
+	}
+	if len(keys) != 1 || keys[0] != Key(2) {
+		t.Fatalf("Expected to find key 2, got %v", keys)
+	}
+}

commit 42aef88f37743d552987d1c068e0f89d1d88dcb6
Author: Ash Vardanian <1983160+ashvardanian@users.noreply.github.com>
Date:   Sun Dec 21 17:51:55 2025 +0000

    Make: Bump SimSIMD

diff --git a/simsimd b/simsimd
index 25eacdc..3e18990 160000
--- a/simsimd
+++ b/simsimd
@@ -1 +1 @@
-Subproject commit 25eacdc6bc541d0e04411de4b5ea06709136fc1a
+Subproject commit 3e18990b79bd09aeb4a28fa1972f2d069bd47fdf

commit 6e84b1f30f14ee43e32a1f3129e4396e0ad0ef7a
Author: Ash Vardanian <1983160+ashvardanian@users.noreply.github.com>
Date:   Sun Dec 21 17:47:31 2025 +0000

    Fix: Missing `switch` cases for settings

diff --git a/golang/lib.go b/golang/lib.go
index fedb530..d5f96db 100644
--- a/golang/lib.go
+++ b/golang/lib.go
@@ -101,6 +101,8 @@ func (m Metric) CValue() C.usearch_metric_kind_t {
 		return C.usearch_metric_cos_k
 	case Haversine:
 		return C.usearch_metric_haversine_k
+	case Divergence:
+		return C.usearch_metric_divergence_k
 	case Pearson:
 		return C.usearch_metric_pearson_k
 	case Hamming:
@@ -134,8 +136,8 @@ const (
 )
 
 // String returns the string representation of the Quantization.
-func (a Quantization) String() string {
-	switch a {
+func (q Quantization) String() string {
+	switch q {
 	case BF16:
 		return "BF16"
 	case F16:
@@ -153,8 +155,8 @@ func (a Quantization) String() string {
 	}
 }
 
-func (a Quantization) CValue() C.usearch_scalar_kind_t {
-	switch a {
+func (q Quantization) CValue() C.usearch_scalar_kind_t {
+	switch q {
 	case F16:
 		return C.usearch_scalar_f16_k
 	case F32:
@@ -1213,6 +1215,8 @@ func Metadata(path string) (c IndexConfig, err error) {
 		c.Quantization = I8
 	case C.usearch_scalar_b1_k:
 		c.Quantization = B1
+	case C.usearch_scalar_bf16_k:
+		c.Quantization = BF16
 	}
 
 	return c, nil

commit ba7d699b3714e984a70252ce4b3b6928e98b2983
Author: Ash Vardanian <1983160+ashvardanian@users.noreply.github.com>
Date:   Sun Dec 21 17:46:28 2025 +0000

    Fix: Keep GoLang vectors alive

diff --git a/golang/lib.go b/golang/lib.go
index fa43ba9..fedb530 100644
--- a/golang/lib.go
+++ b/golang/lib.go
@@ -489,6 +489,7 @@ func (index *Index) AddUnsafe(key Key, vec unsafe.Pointer) error {
 
 	var errorMessage *C.char
 	C.usearch_add(index.handle, (C.usearch_key_t)(key), vec, index.config.Quantization.CValue(), (*C.usearch_error_t)(&errorMessage))
+	runtime.KeepAlive(vec)
 	if errorMessage != nil {
 		return errors.New(C.GoString(errorMessage))
 	}
@@ -594,6 +595,8 @@ func DistanceUnsafe(vec1 unsafe.Pointer, vec2 unsafe.Pointer, vectorDimensions u
 
 	var errorMessage *C.char
 	dist := C.usearch_distance(vec1, vec2, quantization.CValue(), C.size_t(vectorDimensions), metric.CValue(), (*C.usearch_error_t)(&errorMessage))
+	runtime.KeepAlive(vec1)
+	runtime.KeepAlive(vec2)
 	if errorMessage != nil {
 		return 0, errors.New(C.GoString(errorMessage))
 	}
@@ -720,6 +723,7 @@ func (index *Index) SearchUnsafe(query unsafe.Pointer, limit uint) (keys []Key,
 	distances = make([]float32, limit)
 	var errorMessage *C.char
 	resultCount := uint(C.usearch_search(index.handle, query, index.config.Quantization.CValue(), (C.size_t)(limit), (*C.usearch_key_t)(&keys[0]), (*C.usearch_distance_t)(&distances[0]), (*C.usearch_error_t)(&errorMessage)))
+	runtime.KeepAlive(query)
 	runtime.KeepAlive(keys)
 	runtime.KeepAlive(distances)
 	if errorMessage != nil {
@@ -761,6 +765,7 @@ func (index *Index) FilteredSearchUnsafe(query unsafe.Pointer, limit uint, handl
 	resultCount := uint(C.usearch_filtered_search(index.handle, query, index.config.Quantization.CValue(), (C.size_t)(limit),
 		(C.usearch_filtered_search_callback_t)(C.goFilteredSearchCallback), unsafe.Pointer(handler),
 		(*C.usearch_key_t)(&keys[0]), (*C.usearch_distance_t)(&distances[0]), (*C.usearch_error_t)(&errorMessage)))
+	runtime.KeepAlive(query)
 	runtime.KeepAlive(keys)
 	runtime.KeepAlive(distances)
 	runtime.KeepAlive(handler)

commit e99fe4a7258189a85b01b0e4e7f4e7fe8447501d
Merge: 4f02166 55c1ea8
Author: Ash Vardanian <1983160+ashvardanian@users.noreply.github.com>
Date:   Sun Dec 21 17:24:34 2025 +0000

    Merge: Filtered Search for GoLang

commit 55c1ea843870b89a3d99c13a675b5df619765610
Author: Eric Lam <148623+cpegeric@users.noreply.github.com>
Date:   Wed Oct 29 09:48:32 2025 +0000

    Improve: Make FilteredSearchHandler fields public

diff --git a/golang/lib.go b/golang/lib.go
index 3e67ecc..65e0c7b 100644
--- a/golang/lib.go
+++ b/golang/lib.go
@@ -208,8 +208,8 @@ func DefaultConfig(dimensions uint) IndexConfig {
 
 // FilteredSearchHandler include the callback functiona and user data
 type FilteredSearchHandler struct {
-	f    func(key Key, ptr unsafe.Pointer) int
-	data any
+	Callback func(key Key, handler *FilteredSearchHandler) int
+	Data     any
 }
 
 // Index represents a USearch approximate nearest neighbor index.
@@ -734,7 +734,7 @@ func (index *Index) SearchUnsafe(query unsafe.Pointer, limit uint) (keys []Key,
 //export goFilteredSearchCallback
 func goFilteredSearchCallback(key C.usearch_key_t, ptr unsafe.Pointer) C.int {
 	handler := (*FilteredSearchHandler)(ptr)
-	return C.int(handler.f(Key(key), ptr))
+	return C.int(handler.Callback(Key(key), handler))
 }
 
 // Filtred Search performs k-Approximate Nearest Neighbors Search for the closest vectors to the query vector with filtering.
diff --git a/golang/lib_test.go b/golang/lib_test.go
index 5cde0dd..a0d3457 100644
--- a/golang/lib_test.go
+++ b/golang/lib_test.go
@@ -541,13 +541,13 @@ func TestQuantizationTypes(t *testing.T) {
 
 		// Test FilteredSearch
 		handler := &FilteredSearchHandler{
-			f: func(key Key, ptr unsafe.Pointer) int {
+			Callback: func(key Key, handler *FilteredSearchHandler) int {
 				if key%2 == 0 {
 					return 1
 				}
 				return 0
 			},
-			data: int64(1),
+			Data: int64(1),
 		}
 
 		keys, _, err = index.FilteredSearch(vector, 1, handler)
@@ -592,13 +592,13 @@ func TestQuantizationTypes(t *testing.T) {
 
 		// Test F64 FilteredSearchUnsafe
 		handler := &FilteredSearchHandler{
-			f: func(key Key, ptr unsafe.Pointer) int {
+			Callback: func(key Key, handler *FilteredSearchHandler) int {
 				if key%2 == 0 {
 					return 1
 				}
 				return 0
 			},
-			data: int64(1),
+			Data: int64(1),
 		}
 
 		keys, _, err = index.FilteredSearchUnsafe(unsafe.Pointer(&vector[0]), 5, handler)
@@ -639,13 +639,13 @@ func TestQuantizationTypes(t *testing.T) {
 
 		// Test FilteredSearchI8
 		handler := &FilteredSearchHandler{
-			f: func(key Key, ptr unsafe.Pointer) int {
+			Callback: func(key Key, handler *FilteredSearchHandler) int {
 				if key%2 == 0 {
 					return 1
 				}
 				return 0
 			},
-			data: int64(1),
+			Data: int64(1),
 		}
 
 		keys, _, err = index.FilteredSearchI8(vector, 1, handler)
@@ -708,13 +708,13 @@ func TestUnsafeOperations(t *testing.T) {
 
 		// Test FilteredSearchUnsafe
 		handler := &FilteredSearchHandler{
-			f: func(key Key, ptr unsafe.Pointer) int {
+			Callback: func(key Key, handler *FilteredSearchHandler) int {
 				if key%2 == 0 {
 					return 0
 				}
 				return 1
 			},
-			data: int64(1),
+			Data: int64(1),
 		}
 
 		keys, _, err = index.FilteredSearchUnsafe(ptr, 5, handler)

commit 3cd62ce9e4d85f25164ab414c7a75aaadf25a605
Author: Eric Lam <148623+cpegeric@users.noreply.github.com>
Date:   Tue Oct 28 13:17:54 2025 +0000

    Fix: FilteredSearchHandler typo and use correct C function

diff --git a/golang/lib.go b/golang/lib.go
index f18cca4..3e67ecc 100644
--- a/golang/lib.go
+++ b/golang/lib.go
@@ -657,7 +657,7 @@ func (index *Index) Search(query []float32, limit uint) (keys []Key, distances [
 //
 // The actual number of results may be less than limit if the index
 // contains fewer vectors.
-func (index *Index) FilteredSearch(query []float32, limit uint, handler *FilterdSearchHandler) (keys []Key, distances []float32, err error) {
+func (index *Index) FilteredSearch(query []float32, limit uint, handler *FilteredSearchHandler) (keys []Key, distances []float32, err error) {
 	if index.handle == nil {
 		panic("index is uninitialized")
 	}
@@ -678,7 +678,7 @@ func (index *Index) FilteredSearch(query []float32, limit uint, handler *Filterd
 	keys = make([]Key, limit)
 	distances = make([]float32, limit)
 	var errorMessage *C.char
-	resultCount := uint(C.usearch_search(index.handle, unsafe.Pointer(&query[0]), C.usearch_scalar_f32_k, (C.size_t)(limit),
+	resultCount := uint(C.usearch_filtered_search(index.handle, unsafe.Pointer(&query[0]), C.usearch_scalar_f32_k, (C.size_t)(limit),
 		(C.usearch_filtered_search_callback_t)(C.goFilteredSearchCallback), unsafe.Pointer(handler),
 		(*C.usearch_key_t)(&keys[0]), (*C.usearch_distance_t)(&distances[0]), (*C.usearch_error_t)(&errorMessage)))
 	runtime.KeepAlive(query)
@@ -917,7 +917,7 @@ func (index *Index) SearchI8(query []int8, limit uint) (keys []Key, distances []
 	return keys, distances, nil
 }
 
-func (index *Index) FilteredSearchI8(query []int8, limit uint, handler *FilterdSearchHandler) (keys []Key, distances []float32, err error) {
+func (index *Index) FilteredSearchI8(query []int8, limit uint, handler *FilteredSearchHandler) (keys []Key, distances []float32, err error) {
 	if index.handle == nil {
 		panic("index is uninitialized")
 	}
@@ -938,7 +938,7 @@ func (index *Index) FilteredSearchI8(query []int8, limit uint, handler *FilterdS
 	keys = make([]Key, limit)
 	distances = make([]float32, limit)
 	var errorMessage *C.char
-	resultCount := uint(C.usearch_search(index.handle, unsafe.Pointer(&query[0]), C.usearch_scalar_i8_k, (C.size_t)(limit),
+	resultCount := uint(C.usearch_filtered_search(index.handle, unsafe.Pointer(&query[0]), C.usearch_scalar_i8_k, (C.size_t)(limit),
 		(C.usearch_filtered_search_callback_t)(C.goFilteredSearchCallback), unsafe.Pointer(handler),
 		(*C.usearch_key_t)(&keys[0]), (*C.usearch_distance_t)(&distances[0]), (*C.usearch_error_t)(&errorMessage)))
 	runtime.KeepAlive(query)
diff --git a/golang/lib_test.go b/golang/lib_test.go
index 1d96cdf..5cde0dd 100644
--- a/golang/lib_test.go
+++ b/golang/lib_test.go
@@ -538,6 +538,26 @@ func TestQuantizationTypes(t *testing.T) {
 		if len(keys) == 0 || keys[0] != 1 {
 			t.Fatalf("F32 search results incorrect")
 		}
+
+		// Test FilteredSearch
+		handler := &FilteredSearchHandler{
+			f: func(key Key, ptr unsafe.Pointer) int {
+				if key%2 == 0 {
+					return 1
+				}
+				return 0
+			},
+			data: int64(1),
+		}
+
+		keys, _, err = index.FilteredSearch(vector, 1, handler)
+		if err != nil {
+			t.Fatalf("F32 FilteredSearch failed: %v", err)
+		}
+
+		if len(keys) > 0 {
+			t.Fatalf("F32 FilteredSearch returned incorrect results")
+		}
 	})
 
 	t.Run("F64 operations", func(t *testing.T) {
@@ -569,6 +589,26 @@ func TestQuantizationTypes(t *testing.T) {
 		if len(keys) == 0 || keys[0] != 1 {
 			t.Fatalf("F64 search results incorrect")
 		}
+
+		// Test F64 FilteredSearchUnsafe
+		handler := &FilteredSearchHandler{
+			f: func(key Key, ptr unsafe.Pointer) int {
+				if key%2 == 0 {
+					return 1
+				}
+				return 0
+			},
+			data: int64(1),
+		}
+
+		keys, _, err = index.FilteredSearchUnsafe(unsafe.Pointer(&vector[0]), 5, handler)
+		if err != nil {
+			t.Fatalf("F64 FilteredSearchUnsafe failed: %v", err)
+		}
+
+		if len(keys) > 0 {
+			t.Fatalf("F64 FilteredSearchUnsafe returned incorrect results")
+		}
 	})
 
 	t.Run("I8 operations", func(t *testing.T) {
@@ -596,6 +636,26 @@ func TestQuantizationTypes(t *testing.T) {
 		if len(keys) == 0 || keys[0] != 1 {
 			t.Fatalf("I8 search results incorrect")
 		}
+
+		// Test FilteredSearchI8
+		handler := &FilteredSearchHandler{
+			f: func(key Key, ptr unsafe.Pointer) int {
+				if key%2 == 0 {
+					return 1
+				}
+				return 0
+			},
+			data: int64(1),
+		}
+
+		keys, _, err = index.FilteredSearchI8(vector, 1, handler)
+		if err != nil {
+			t.Fatalf("FilteredSearchI8 failed: %v", err)
+		}
+
+		if len(keys) > 0 {
+			t.Fatalf("FilteredSearchI8 returned incorrect results")
+		}
 	})
 }
 
@@ -657,7 +717,7 @@ func TestUnsafeOperations(t *testing.T) {
 			data: int64(1),
 		}
 
-		keys, distances, err = index.FilteredSearchUnsafe(ptr, 5, handler)
+		keys, _, err = index.FilteredSearchUnsafe(ptr, 5, handler)
 		if err != nil {
 			t.Fatalf("FilteredSearchUnsafe failed: %v", err)
 		}

commit 1f3e08603eb5c62e38c5857d9459e510bcaab380
Author: Eric Lam <148623+cpegeric@users.noreply.github.com>
Date:   Tue Oct 28 13:06:58 2025 +0000

    Add: FilteredSearch and FilteredSearchI8 functions

diff --git a/golang/lib.go b/golang/lib.go
index b804cbb..f18cca4 100644
--- a/golang/lib.go
+++ b/golang/lib.go
@@ -644,6 +644,56 @@ func (index *Index) Search(query []float32, limit uint) (keys []Key, distances [
 	return keys, distances, nil
 }
 
+// Search finds the k nearest neighbors to the query vector.
+//
+// Parameters:
+//   - query: Must have exactly Dimensions() elements
+//   - limit: Maximum number of results to return
+//
+// Returns:
+//   - keys: IDs of the nearest vectors (up to limit)
+//   - distances: Distance to each result (same length as keys)
+//   - err: Error if query is invalid or search fails
+//
+// The actual number of results may be less than limit if the index
+// contains fewer vectors.
+func (index *Index) FilteredSearch(query []float32, limit uint, handler *FilterdSearchHandler) (keys []Key, distances []float32, err error) {
+	if index.handle == nil {
+		panic("index is uninitialized")
+	}
+
+	if len(query) == 0 {
+		return nil, nil, errors.New("query vector cannot be empty")
+	}
+	if uint(len(query)) != index.config.Dimensions {
+		return nil, nil, fmt.Errorf("query dimension mismatch: got %d, expected %d", len(query), index.config.Dimensions)
+	}
+	if handler == nil {
+		return nil, nil, errors.New("filtered search handler cannot be nil")
+	}
+	if limit == 0 {
+		return []Key{}, []float32{}, nil
+	}
+
+	keys = make([]Key, limit)
+	distances = make([]float32, limit)
+	var errorMessage *C.char
+	resultCount := uint(C.usearch_search(index.handle, unsafe.Pointer(&query[0]), C.usearch_scalar_f32_k, (C.size_t)(limit),
+		(C.usearch_filtered_search_callback_t)(C.goFilteredSearchCallback), unsafe.Pointer(handler),
+		(*C.usearch_key_t)(&keys[0]), (*C.usearch_distance_t)(&distances[0]), (*C.usearch_error_t)(&errorMessage)))
+	runtime.KeepAlive(query)
+	runtime.KeepAlive(keys)
+	runtime.KeepAlive(distances)
+	runtime.KeepAlive(handler)
+	if errorMessage != nil {
+		return nil, nil, errors.New(C.GoString(errorMessage))
+	}
+
+	keys = keys[:resultCount]
+	distances = distances[:resultCount]
+	return keys, distances, nil
+}
+
 // SearchUnsafe performs k-Approximate Nearest Neighbors Search using an unsafe pointer.
 //
 // SAFETY REQUIREMENTS:
@@ -867,6 +917,43 @@ func (index *Index) SearchI8(query []int8, limit uint) (keys []Key, distances []
 	return keys, distances, nil
 }
 
+func (index *Index) FilteredSearchI8(query []int8, limit uint, handler *FilterdSearchHandler) (keys []Key, distances []float32, err error) {
+	if index.handle == nil {
+		panic("index is uninitialized")
+	}
+
+	if len(query) == 0 {
+		return nil, nil, errors.New("query vector cannot be empty")
+	}
+	if uint(len(query)) != index.config.Dimensions {
+		return nil, nil, fmt.Errorf("query dimension mismatch: got %d, expected %d", len(query), index.config.Dimensions)
+	}
+	if handler == nil {
+		return nil, nil, errors.New("filtered search handler cannot be nil")
+	}
+	if limit == 0 {
+		return []Key{}, []float32{}, nil
+	}
+
+	keys = make([]Key, limit)
+	distances = make([]float32, limit)
+	var errorMessage *C.char
+	resultCount := uint(C.usearch_search(index.handle, unsafe.Pointer(&query[0]), C.usearch_scalar_i8_k, (C.size_t)(limit),
+		(C.usearch_filtered_search_callback_t)(C.goFilteredSearchCallback), unsafe.Pointer(handler),
+		(*C.usearch_key_t)(&keys[0]), (*C.usearch_distance_t)(&distances[0]), (*C.usearch_error_t)(&errorMessage)))
+	runtime.KeepAlive(query)
+	runtime.KeepAlive(keys)
+	runtime.KeepAlive(distances)
+	runtime.KeepAlive(handler)
+	if errorMessage != nil {
+		return nil, nil, errors.New(C.GoString(errorMessage))
+	}
+
+	keys = keys[:resultCount]
+	distances = distances[:resultCount]
+	return keys, distances, nil
+}
+
 // DistanceI8 computes the distance between two int8 vectors.
 //
 // Example:

commit 0df8511bfc869bcf924fe73e5d4239faa096863a
Author: Eric Lam <148623+cpegeric@users.noreply.github.com>
Date:   Tue Oct 28 12:58:37 2025 +0000

    Add: Nil handler validation in FilteredSearchUnsafe

diff --git a/golang/lib.go b/golang/lib.go
index 70781a5..b804cbb 100644
--- a/golang/lib.go
+++ b/golang/lib.go
@@ -696,6 +696,11 @@ func (index *Index) FilteredSearchUnsafe(query unsafe.Pointer, limit uint, handl
 	if query == nil {
 		return nil, nil, errors.New("query pointer cannot be nil")
 	}
+
+	if handler == nil {
+		return nil, nil, errors.New("filtered search handler cannot be nil")
+	}
+
 	if limit == 0 {
 		return []Key{}, []float32{}, nil
 	}

commit a17c6fa39cf914f9b8f7764179e52a9374d22216
Author: Eric Lam <148623+cpegeric@users.noreply.github.com>
Date:   Tue Oct 28 12:55:38 2025 +0000

    Improve: Add data field to FilteredSearchHandler test

diff --git a/golang/lib_test.go b/golang/lib_test.go
index 42c708c..1d96cdf 100644
--- a/golang/lib_test.go
+++ b/golang/lib_test.go
@@ -654,6 +654,7 @@ func TestUnsafeOperations(t *testing.T) {
 				}
 				return 1
 			},
+			data: int64(1),
 		}
 
 		keys, distances, err = index.FilteredSearchUnsafe(ptr, 5, handler)

commit 95f713ef6359ed78e9965d58b400b691dab9ebce
Author: Eric Lam <148623+cpegeric@users.noreply.github.com>
Date:   Tue Oct 28 12:54:22 2025 +0000

    Fix: Filtered search test logic and remove debug output

diff --git a/golang/lib_test.go b/golang/lib_test.go
index 4a67099..42c708c 100644
--- a/golang/lib_test.go
+++ b/golang/lib_test.go
@@ -649,11 +649,10 @@ func TestUnsafeOperations(t *testing.T) {
 		// Test FilteredSearchUnsafe
 		handler := &FilteredSearchHandler{
 			f: func(key Key, ptr unsafe.Pointer) int {
-				fmt.Println(key)
 				if key%2 == 0 {
-					return 1
+					return 0
 				}
-				return 0
+				return 1
 			},
 		}
 
@@ -662,13 +661,9 @@ func TestUnsafeOperations(t *testing.T) {
 			t.Fatalf("FilteredSearchUnsafe failed: %v", err)
 		}
 
-		if len(keys) == 0 || keys[0] != 100 {
+		if len(keys) > 0 {
 			t.Fatalf("FilteredSearchUnsafe returned incorrect results")
 		}
-
-		if math.Abs(float64(distances[0])) > distanceTolerance {
-			t.Fatalf("Expected near-zero distance for exact match, got %f", distances[0])
-		}
 	})
 }
 

commit 72a9f5aadd9429f86567fa8a2e9bca295df2f6dc
Author: Eric Lam <148623+cpegeric@users.noreply.github.com>
Date:   Tue Oct 28 12:50:32 2025 +0000

    Improve: FilteredSearchUnsafe documentation

diff --git a/golang/lib.go b/golang/lib.go
index 3a7eced..70781a5 100644
--- a/golang/lib.go
+++ b/golang/lib.go
@@ -687,7 +687,7 @@ func goFilteredSearchCallback(key C.usearch_key_t, ptr unsafe.Pointer) C.int {
 	return C.int(handler.f(Key(key), ptr))
 }
 
-// Search performs k-Approximate Nearest Neighbors Search for the closest vectors to the query vector.
+// Filtred Search performs k-Approximate Nearest Neighbors Search for the closest vectors to the query vector with filtering.
 func (index *Index) FilteredSearchUnsafe(query unsafe.Pointer, limit uint, handler *FilteredSearchHandler) (keys []Key, distances []float32, err error) {
 	if index.handle == nil {
 		panic("index is uninitialized")

commit 4829a29a9f4fb428cb743b604e5b07d5b3f6fd58
Author: Eric Lam <148623+cpegeric@users.noreply.github.com>
Date:   Tue Oct 28 12:47:58 2025 +0000

    Add: Filtered search callback support in GoLang bindings

diff --git a/c/lib.cpp b/c/lib.cpp
index e391467..7e5527e 100644
--- a/c/lib.cpp
+++ b/c/lib.cpp
@@ -413,7 +413,7 @@ USEARCH_EXPORT size_t usearch_search(
 USEARCH_EXPORT size_t usearch_filtered_search(                                 //
     usearch_index_t index,                                                     //
     void const* query, usearch_scalar_kind_t query_kind, size_t results_limit, //
-    int (*filter)(usearch_key_t key, void* filter_state), void* filter_state,  //
+    usearch_filtered_search_callback_t filter, void* filter_state,  //
     usearch_key_t* found_keys, usearch_distance_t* found_distances, usearch_error_t* error) {
 
     USEARCH_ASSERT(index && query && filter && error && "Missing arguments");
diff --git a/c/usearch.h b/c/usearch.h
index c611645..7921c19 100644
--- a/c/usearch.h
+++ b/c/usearch.h
@@ -109,6 +109,10 @@ USEARCH_EXPORT typedef struct usearch_init_options_t {
     bool multi;
 } usearch_init_options_t;
 
+extern int goFilteredSearchCallback(usearch_key_t, void*);
+
+USEARCH_EXPORT typedef int (*usearch_filtered_search_callback_t)(usearch_key_t, void*);
+
 /**
  *  @brief Retrieves the version of the library.
  *  @return The version of the library.
@@ -391,7 +395,7 @@ USEARCH_EXPORT size_t usearch_search(                                         //
 USEARCH_EXPORT size_t usearch_filtered_search(                                //
     usearch_index_t index,                                                    //
     void const* query_vector, usearch_scalar_kind_t query_kind, size_t count, //
-    int (*filter)(usearch_key_t key, void* filter_state), void* filter_state, //
+    usearch_filtered_search_callback_t filter, void* filter_state, //
     usearch_key_t* keys, usearch_distance_t* distances, usearch_error_t* error);
 
 /**
diff --git a/golang/lib.go b/golang/lib.go
index 8fa39a2..3a7eced 100644
--- a/golang/lib.go
+++ b/golang/lib.go
@@ -206,6 +206,12 @@ func DefaultConfig(dimensions uint) IndexConfig {
 	return c
 }
 
+// FilteredSearchHandler include the callback functiona and user data
+type FilteredSearchHandler struct {
+	f    func(key Key, ptr unsafe.Pointer) int
+	data any
+}
+
 // Index represents a USearch approximate nearest neighbor index.
 // It implements io.Closer for idiomatic resource cleanup.
 //
@@ -675,6 +681,43 @@ func (index *Index) SearchUnsafe(query unsafe.Pointer, limit uint) (keys []Key,
 	return keys, distances, nil
 }
 
+//export goFilteredSearchCallback
+func goFilteredSearchCallback(key C.usearch_key_t, ptr unsafe.Pointer) C.int {
+	handler := (*FilteredSearchHandler)(ptr)
+	return C.int(handler.f(Key(key), ptr))
+}
+
+// Search performs k-Approximate Nearest Neighbors Search for the closest vectors to the query vector.
+func (index *Index) FilteredSearchUnsafe(query unsafe.Pointer, limit uint, handler *FilteredSearchHandler) (keys []Key, distances []float32, err error) {
+	if index.handle == nil {
+		panic("index is uninitialized")
+	}
+
+	if query == nil {
+		return nil, nil, errors.New("query pointer cannot be nil")
+	}
+	if limit == 0 {
+		return []Key{}, []float32{}, nil
+	}
+
+	keys = make([]Key, limit)
+	distances = make([]float32, limit)
+	var errorMessage *C.char
+	resultCount := uint(C.usearch_filtered_search(index.handle, query, index.config.Quantization.CValue(), (C.size_t)(limit),
+		(C.usearch_filtered_search_callback_t)(C.goFilteredSearchCallback), unsafe.Pointer(handler),
+		(*C.usearch_key_t)(&keys[0]), (*C.usearch_distance_t)(&distances[0]), (*C.usearch_error_t)(&errorMessage)))
+	runtime.KeepAlive(keys)
+	runtime.KeepAlive(distances)
+	runtime.KeepAlive(handler)
+	if errorMessage != nil {
+		return nil, nil, errors.New(C.GoString(errorMessage))
+	}
+
+	keys = keys[:resultCount]
+	distances = distances[:resultCount]
+	return keys, distances, nil
+}
+
 // ExactSearch performs multithreaded exact nearest neighbors search.
 // Unlike the index-based search, this computes distances to all vectors in the dataset.
 //
diff --git a/golang/lib_test.go b/golang/lib_test.go
index 6409dce..4a67099 100644
--- a/golang/lib_test.go
+++ b/golang/lib_test.go
@@ -30,19 +30,19 @@ func createTestIndex(t *testing.T, dimensions uint, quantization Quantization) *
 }
 
 func generateTestVector(dimensions uint) []float32 {
-    vector := make([]float32, dimensions)
-    for i := uint(0); i < dimensions; i++ {
-        vector[i] = float32(i) + 0.1
-    }
-    return vector
+	vector := make([]float32, dimensions)
+	for i := uint(0); i < dimensions; i++ {
+		vector[i] = float32(i) + 0.1
+	}
+	return vector
 }
 
 func generateTestVectorI8(dimensions uint) []int8 {
-    vector := make([]int8, dimensions)
-    for i := uint(0); i < dimensions; i++ {
-        vector[i] = int8((i % 127) + 1)
-    }
-    return vector
+	vector := make([]int8, dimensions)
+	for i := uint(0); i < dimensions; i++ {
+		vector[i] = int8((i % 127) + 1)
+	}
+	return vector
 }
 
 func populateIndex(t *testing.T, index *Index, vectorCount int) [][]float32 {
@@ -57,16 +57,16 @@ func populateIndex(t *testing.T, index *Index, vectorCount int) [][]float32 {
 		t.Fatalf("Failed to get dimensions: %v", err)
 	}
 
-    for i := 0; i < vectorCount; i++ {
-        vector := generateTestVector(dimensions)
-        vector[0] = float32(i) // Make each vector unique
-        vectors[i] = vector
+	for i := 0; i < vectorCount; i++ {
+		vector := generateTestVector(dimensions)
+		vector[0] = float32(i) // Make each vector unique
+		vectors[i] = vector
 
-        err = index.Add(Key(i), vector)
-        if err != nil {
-            t.Fatalf("Failed to add vector %d: %v", i, err)
-        }
-    }
+		err = index.Add(Key(i), vector)
+		if err != nil {
+			t.Fatalf("Failed to add vector %d: %v", i, err)
+		}
+	}
 	return vectors
 }
 
@@ -189,12 +189,12 @@ func TestBasicOperations(t *testing.T) {
 			t.Fatalf("Failed to reserve capacity: %v", err)
 		}
 
-        // Add a vector
-        vector := generateTestVector(defaultTestDimensions)
-        vector[0] = 42.0
-        vector[1] = 24.0
+		// Add a vector
+		vector := generateTestVector(defaultTestDimensions)
+		vector[0] = 42.0
+		vector[1] = 24.0
 
-        err := index.Add(100, vector)
+		err := index.Add(100, vector)
 		if err != nil {
 			t.Fatalf("Failed to add vector: %v", err)
 		}
@@ -524,13 +524,13 @@ func TestQuantizationTypes(t *testing.T) {
 		if err := index.Reserve(1); err != nil {
 			t.Fatalf("Failed to reserve capacity: %v", err)
 		}
-        vector := generateTestVector(32)
-        err := index.Add(1, vector)
+		vector := generateTestVector(32)
+		err := index.Add(1, vector)
 		if err != nil {
 			t.Fatalf("F32 Add failed: %v", err)
 		}
 
-        keys, _, err := index.Search(vector, 1)
+		keys, _, err := index.Search(vector, 1)
 		if err != nil {
 			t.Fatalf("F32 Search failed: %v", err)
 		}
@@ -551,17 +551,17 @@ func TestQuantizationTypes(t *testing.T) {
 		if err := index.Reserve(1); err != nil {
 			t.Fatalf("Failed to reserve capacity: %v", err)
 		}
-        vector := make([]float64, 32)
-        for i := range vector {
-            vector[i] = float64(i) + 0.5
-        }
+		vector := make([]float64, 32)
+		for i := range vector {
+			vector[i] = float64(i) + 0.5
+		}
 
-        err := index.AddUnsafe(1, unsafe.Pointer(&vector[0]))
+		err := index.AddUnsafe(1, unsafe.Pointer(&vector[0]))
 		if err != nil {
 			t.Fatalf("F64 AddUnsafe failed: %v", err)
 		}
 
-        keys, _, err := index.SearchUnsafe(unsafe.Pointer(&vector[0]), 1)
+		keys, _, err := index.SearchUnsafe(unsafe.Pointer(&vector[0]), 1)
 		if err != nil {
 			t.Fatalf("F64 SearchUnsafe failed: %v", err)
 		}
@@ -582,13 +582,13 @@ func TestQuantizationTypes(t *testing.T) {
 		if err := index.Reserve(1); err != nil {
 			t.Fatalf("Failed to reserve capacity: %v", err)
 		}
-        vector := generateTestVectorI8(32)
-        err := index.AddI8(1, vector)
+		vector := generateTestVectorI8(32)
+		err := index.AddI8(1, vector)
 		if err != nil {
 			t.Fatalf("I8 Add failed: %v", err)
 		}
 
-        keys, _, err := index.SearchI8(vector, 1)
+		keys, _, err := index.SearchI8(vector, 1)
 		if err != nil {
 			t.Fatalf("I8 Search failed: %v", err)
 		}
@@ -614,8 +614,8 @@ func TestUnsafeOperations(t *testing.T) {
 		if err := index.Reserve(1); err != nil {
 			t.Fatalf("Failed to reserve capacity: %v", err)
 		}
-        vector := generateTestVector(64)
-        ptr := unsafe.Pointer(&vector[0])
+		vector := generateTestVector(64)
+		ptr := unsafe.Pointer(&vector[0])
 
 		// Test AddUnsafe
 		err := index.AddUnsafe(100, ptr)
@@ -645,6 +645,30 @@ func TestUnsafeOperations(t *testing.T) {
 		if math.Abs(float64(distances[0])) > distanceTolerance {
 			t.Fatalf("Expected near-zero distance for exact match, got %f", distances[0])
 		}
+
+		// Test FilteredSearchUnsafe
+		handler := &FilteredSearchHandler{
+			f: func(key Key, ptr unsafe.Pointer) int {
+				fmt.Println(key)
+				if key%2 == 0 {
+					return 1
+				}
+				return 0
+			},
+		}
+
+		keys, distances, err = index.FilteredSearchUnsafe(ptr, 5, handler)
+		if err != nil {
+			t.Fatalf("FilteredSearchUnsafe failed: %v", err)
+		}
+
+		if len(keys) == 0 || keys[0] != 100 {
+			t.Fatalf("FilteredSearchUnsafe returned incorrect results")
+		}
+
+		if math.Abs(float64(distances[0])) > distanceTolerance {
+			t.Fatalf("Expected near-zero distance for exact match, got %f", distances[0])
+		}
 	})
 }
 
@@ -671,12 +695,12 @@ func TestConcurrentInsertions(t *testing.T) {
 		_ = index.ChangeThreadsAdd(uint(runtime.NumCPU()))
 
 		for i := 0; i < totalVectors; i++ {
-            vector := generateTestVector(64)
-            vector[0] = float32(i)
-            if err := index.Add(Key(i), vector); err != nil {
-                t.Fatalf("Insertion failed at %d: %v", i, err)
-            }
-        }
+			vector := generateTestVector(64)
+			vector[0] = float32(i)
+			if err := index.Add(Key(i), vector); err != nil {
+				t.Fatalf("Insertion failed at %d: %v", i, err)
+			}
+		}
 
 		// Verify final count
 		finalSize, err := index.Len()

commit 4f0216674482059fb3524c2237ec725281c6a34c
Author: Yoonseok Kim <43584573+yoonseok-kim@users.noreply.github.com>
Date:   Mon Dec 22 01:47:46 2025 +0900

    Improve: Fewer conditional locks for immutable index views (#689)
    
    Co-authored-by: Ash Vardanian <1983160+ashvardanian@users.noreply.github.com>

diff --git a/include/usearch/index.hpp b/include/usearch/index.hpp
index 3a9d8a1..bdbd2ae 100644
--- a/include/usearch/index.hpp
+++ b/include/usearch/index.hpp
@@ -3999,12 +3999,13 @@ class index_gt {
         if (!is_dummy<prefetch_at>())
             prefetch(citerator_at(closest_slot), citerator_at(closest_slot) + 1);
 
+        bool const need_lock = !is_immutable();
         distance_t closest_dist = context.measure(query, citerator_at(closest_slot), metric);
         for (level_t level = begin_level; level > end_level; --level) {
             bool changed;
             do {
                 changed = false;
-                node_lock_t closest_lock = node_lock_(closest_slot);
+                optional_node_lock_t closest_lock = optional_node_lock_(closest_slot, need_lock);
                 neighbors_ref_t closest_neighbors = neighbors_non_base_(node_at_(closest_slot), level);
 
                 // Optional prefetching

commit 68c23b0487b9711b471345a8cf1a45d34e9e6f80
Merge: 7685a67 abcbf09
Author: Ash Vardanian <1983160+ashvardanian@users.noreply.github.com>
Date:   Sun Dec 21 16:45:53 2025 +0000

    Fix: Exact search `maxResults` in GoLang

commit abcbf0984172d585171489a8116e20b4c94db6b9
Author: Eric Lam <148623+cpegeric@users.noreply.github.com>
Date:   Thu Dec 4 17:52:31 2025 +0000

    Update: add more tests

diff --git a/golang/lib_test.go b/golang/lib_test.go
index c959a39..279f164 100644
--- a/golang/lib_test.go
+++ b/golang/lib_test.go
@@ -854,6 +854,64 @@ func TestExactSearch(t *testing.T) {
 			}
 		}
 	})
+
+	t.Run("unsafe exact search", func(t *testing.T) {
+		const datasetSize = 10
+		const querySize = 10
+		const vectorDims = 3
+		const maxResults = 1
+
+		dataset := []float32{0.57402676, 0.416747, 0.7048512,
+			0.031865682, 0.81882423, 0.57315916,
+			0.2874403, 0.045098174, 0.95673627,
+			0.006364229, 0.71774554, 0.6962764,
+			0.33764744, 0.44205195, 0.831014,
+			0.3366346, 0.829091, 0.4464138,
+			0.11070566, 0.96180826, 0.2503381,
+			0.538731, 0.2840365, 0.7931533,
+			0.7719648, 0.20657142, 0.6011644,
+			0.21957317, 0.94966024, 0.22345713,
+		}
+
+		queries := []float32{0.57402676, 0.416747, 0.7048512,
+			0.031865682, 0.81882423, 0.57315916,
+			0.2874403, 0.045098174, 0.95673627,
+			0.006364229, 0.71774554, 0.6962764,
+			0.33764744, 0.44205195, 0.831014,
+			0.3366346, 0.829091, 0.4464138,
+			0.11070566, 0.96180826, 0.2503381,
+			0.538731, 0.2840365, 0.7931533,
+			0.7719648, 0.20657142, 0.6011644,
+			0.21957317, 0.94966024, 0.22345713,
+		}
+
+		keys, distances, err := ExactSearchUnsafe(
+			unsafe.Pointer(&dataset[0]), unsafe.Pointer(&queries[0]),
+			datasetSize, querySize,
+			vectorDims, vectorDims, // Stride in bytes for int8
+			vectorDims, L2sq, F32,
+			maxResults, 0, // maxResults=3, numThreads=0 (auto)
+		)
+
+		if err != nil {
+			t.Fatalf("ExactSearchI8 failed: %v", err)
+		}
+
+		if len(keys) != maxResults*querySize || len(distances) != maxResults*querySize {
+			t.Fatalf("Expected 3*querySize results from ExactSearchI8, got %d keys and %d distances",
+				len(keys), len(distances))
+		}
+
+		fmt.Printf("keys %v\n", keys)
+		fmt.Printf("distances %v\n", distances)
+
+		for i := 0; i < querySize; i++ {
+			if keys[i] != Key(i) || distances[i] != 0 {
+				t.Fatalf("Expected same results from ExactSearch for all keys and distances")
+			}
+		}
+
+	})
 }
 
 func TestDistanceCalculations(t *testing.T) {

commit 8938d6e35e1de86485314b07dbae0eb9845fbb0a
Author: Eric Lam <148623+cpegeric@users.noreply.github.com>
Date:   Thu Dec 4 17:52:16 2025 +0000

    Fix: static is not thread safe

diff --git a/c/lib.cpp b/c/lib.cpp
index e391467..4aa8d40 100644
--- a/c/lib.cpp
+++ b/c/lib.cpp
@@ -478,7 +478,7 @@ USEARCH_EXPORT void usearch_exact_search(                             //
 
     metric_punned_t metric(dimensions, metric_kind_to_cpp(metric_kind), scalar_kind_to_cpp(scalar_kind));
     executor_default_t executor(threads);
-    static exact_search_t search;
+    exact_search_t search;
     exact_search_results_t result = search(                    //
         (byte_t const*)dataset, dataset_count, dataset_stride, //
         (byte_t const*)queries, queries_count, queries_stride, //

commit f1092691ba8ea8a5f9f290207049253f70a7068c
Author: Eric Lam <148623+cpegeric@users.noreply.github.com>
Date:   Thu Dec 4 12:36:43 2025 +0000

    Fix: check maxResults > 0

diff --git a/golang/lib.go b/golang/lib.go
index 13fc1b5..06b0980 100644
--- a/golang/lib.go
+++ b/golang/lib.go
@@ -703,6 +703,9 @@ func ExactSearch(dataset []float32, queries []float32, datasetSize uint, queryCo
 	if (len(queries) % int(vectorDimensions)) != 0 {
 		return nil, nil, errors.New("queries length must be a multiple of the dimensions")
 	}
+	if maxResults == 0 {
+		return nil, nil, errors.New("maxResults must be greater than zero")
+	}
 
 	keys = make([]Key, queryCount*maxResults)
 	distances = make([]float32, queryCount*maxResults)
@@ -742,8 +745,8 @@ func ExactSearchUnsafe(dataset unsafe.Pointer, queries unsafe.Pointer, datasetSi
 	if dataset == nil || queries == nil {
 		return nil, nil, errors.New("dataset and queries pointers cannot be nil")
 	}
-	if vectorDimensions == 0 || datasetSize == 0 || queryCount == 0 {
-		return nil, nil, errors.New("dimensions and sizes must be greater than zero")
+	if vectorDimensions == 0 || datasetSize == 0 || queryCount == 0 || maxResults == 0 {
+		return nil, nil, errors.New("dimensions, query count, max results and sizes must be greater than zero")
 	}
 
 	keys = make([]Key, queryCount*maxResults)
@@ -859,6 +862,9 @@ func ExactSearchI8(dataset []int8, queries []int8, datasetSize uint, queryCount
 	if vectorDimensions == 0 {
 		return nil, nil, errors.New("dimensions must be greater than zero")
 	}
+	if maxResults == 0 {
+		return nil, nil, errors.New("maxResults must be greater than zero")
+	}
 	keys = make([]Key, queryCount*maxResults)
 	distances = make([]float32, queryCount*maxResults)
 	resultKeysStride := uint32(maxResults * 8)      // int64 - 8 bytes

commit c8adc058982b4420e98a45755b90aa1ff80cf9a8
Author: Eric Lam <148623+cpegeric@users.noreply.github.com>
Date:   Thu Dec 4 12:29:46 2025 +0000

    Fix: exact search return results with size querySize * maxResults

diff --git a/golang/lib.go b/golang/lib.go
index 8fa39a2..13fc1b5 100644
--- a/golang/lib.go
+++ b/golang/lib.go
@@ -689,7 +689,7 @@ func (index *Index) SearchUnsafe(query unsafe.Pointer, limit uint) (keys []Key,
 //   - numThreads: Number of threads to use (0 for auto-detection)
 func ExactSearch(dataset []float32, queries []float32, datasetSize uint, queryCount uint,
 	datasetStride uint, queryStride uint, vectorDimensions uint, metric Metric,
-	maxResults uint, numThreads uint, resultKeysStride uint, resultDistancesStride uint) (keys []Key, distances []float32, err error) {
+	maxResults uint, numThreads uint) (keys []Key, distances []float32, err error) {
 
 	if len(dataset) == 0 || len(queries) == 0 {
 		return nil, nil, errors.New("dataset and queries cannot be empty")
@@ -704,8 +704,11 @@ func ExactSearch(dataset []float32, queries []float32, datasetSize uint, queryCo
 		return nil, nil, errors.New("queries length must be a multiple of the dimensions")
 	}
 
-	keys = make([]Key, maxResults)
-	distances = make([]float32, maxResults)
+	keys = make([]Key, queryCount*maxResults)
+	distances = make([]float32, queryCount*maxResults)
+	resultKeysStride := uint32(maxResults * 8)      // int64 - 8 bytes
+	resultDistancesStride := uint32(maxResults * 4) // float32 - 4 bytes
+
 	var errorMessage *C.char
 	C.usearch_exact_search(unsafe.Pointer(&dataset[0]), C.size_t(datasetSize), C.size_t(datasetStride), unsafe.Pointer(&queries[0]), C.size_t(queryCount), C.size_t(queryStride),
 		C.usearch_scalar_f32_k, C.size_t(vectorDimensions), metric.CValue(), C.size_t(maxResults), C.size_t(numThreads),
@@ -718,8 +721,6 @@ func ExactSearch(dataset []float32, queries []float32, datasetSize uint, queryCo
 		return nil, nil, errors.New(C.GoString(errorMessage))
 	}
 
-	keys = keys[:maxResults]
-	distances = distances[:maxResults]
 	return keys, distances, nil
 }
 
@@ -736,7 +737,7 @@ func ExactSearch(dataset []float32, queries []float32, datasetSize uint, queryCo
 // For contiguous data, use vectorDimensions * sizeof(element_type).
 func ExactSearchUnsafe(dataset unsafe.Pointer, queries unsafe.Pointer, datasetSize uint, queryCount uint,
 	datasetStride uint, queryStride uint, vectorDimensions uint, metric Metric, quantization Quantization,
-	maxResults uint, numThreads uint, resultKeysStride uint, resultDistancesStride uint) (keys []Key, distances []float32, err error) {
+	maxResults uint, numThreads uint) (keys []Key, distances []float32, err error) {
 
 	if dataset == nil || queries == nil {
 		return nil, nil, errors.New("dataset and queries pointers cannot be nil")
@@ -745,8 +746,10 @@ func ExactSearchUnsafe(dataset unsafe.Pointer, queries unsafe.Pointer, datasetSi
 		return nil, nil, errors.New("dimensions and sizes must be greater than zero")
 	}
 
-	keys = make([]Key, maxResults)
-	distances = make([]float32, maxResults)
+	keys = make([]Key, queryCount*maxResults)
+	distances = make([]float32, queryCount*maxResults)
+	resultKeysStride := uint32(maxResults * 8)      // int64 - 8 bytes
+	resultDistancesStride := uint32(maxResults * 4) // float32 - 4 bytes
 	var errorMessage *C.char
 	C.usearch_exact_search(dataset, C.size_t(datasetSize), C.size_t(datasetStride), queries, C.size_t(queryCount), C.size_t(queryStride),
 		quantization.CValue(), C.size_t(vectorDimensions), metric.CValue(), C.size_t(maxResults), C.size_t(numThreads),
@@ -757,8 +760,6 @@ func ExactSearchUnsafe(dataset unsafe.Pointer, queries unsafe.Pointer, datasetSi
 		return nil, nil, errors.New(C.GoString(errorMessage))
 	}
 
-	keys = keys[:maxResults]
-	distances = distances[:maxResults]
 	return keys, distances, nil
 }
 
@@ -850,7 +851,7 @@ func DistanceI8(vec1 []int8, vec2 []int8, vectorDimensions uint, metric Metric)
 // For contiguous int8 data, use vectorDimensions * 1 byte.
 func ExactSearchI8(dataset []int8, queries []int8, datasetSize uint, queryCount uint,
 	datasetStride uint, queryStride uint, vectorDimensions uint, metric Metric,
-	maxResults uint, numThreads uint, resultKeysStride uint, resultDistancesStride uint) (keys []Key, distances []float32, err error) {
+	maxResults uint, numThreads uint) (keys []Key, distances []float32, err error) {
 
 	if len(dataset) == 0 || len(queries) == 0 {
 		return nil, nil, errors.New("dataset and queries cannot be empty")
@@ -858,9 +859,10 @@ func ExactSearchI8(dataset []int8, queries []int8, datasetSize uint, queryCount
 	if vectorDimensions == 0 {
 		return nil, nil, errors.New("dimensions must be greater than zero")
 	}
-
-	keys = make([]Key, maxResults)
-	distances = make([]float32, maxResults)
+	keys = make([]Key, queryCount*maxResults)
+	distances = make([]float32, queryCount*maxResults)
+	resultKeysStride := uint32(maxResults * 8)      // int64 - 8 bytes
+	resultDistancesStride := uint32(maxResults * 4) // float32 - 4 bytes
 	var errorMessage *C.char
 	C.usearch_exact_search(unsafe.Pointer(&dataset[0]), C.size_t(datasetSize), C.size_t(datasetStride), unsafe.Pointer(&queries[0]), C.size_t(queryCount), C.size_t(queryStride),
 		C.usearch_scalar_i8_k, C.size_t(vectorDimensions), metric.CValue(), C.size_t(maxResults), C.size_t(numThreads),
@@ -872,8 +874,6 @@ func ExactSearchI8(dataset []int8, queries []int8, datasetSize uint, queryCount
 	if errorMessage != nil {
 		return nil, nil, errors.New(C.GoString(errorMessage))
 	}
-	keys = keys[:maxResults]
-	distances = distances[:maxResults]
 	return keys, distances, nil
 }
 
diff --git a/golang/lib_test.go b/golang/lib_test.go
index 6409dce..c959a39 100644
--- a/golang/lib_test.go
+++ b/golang/lib_test.go
@@ -30,19 +30,19 @@ func createTestIndex(t *testing.T, dimensions uint, quantization Quantization) *
 }
 
 func generateTestVector(dimensions uint) []float32 {
-    vector := make([]float32, dimensions)
-    for i := uint(0); i < dimensions; i++ {
-        vector[i] = float32(i) + 0.1
-    }
-    return vector
+	vector := make([]float32, dimensions)
+	for i := uint(0); i < dimensions; i++ {
+		vector[i] = float32(i) + 0.1
+	}
+	return vector
 }
 
 func generateTestVectorI8(dimensions uint) []int8 {
-    vector := make([]int8, dimensions)
-    for i := uint(0); i < dimensions; i++ {
-        vector[i] = int8((i % 127) + 1)
-    }
-    return vector
+	vector := make([]int8, dimensions)
+	for i := uint(0); i < dimensions; i++ {
+		vector[i] = int8((i % 127) + 1)
+	}
+	return vector
 }
 
 func populateIndex(t *testing.T, index *Index, vectorCount int) [][]float32 {
@@ -57,16 +57,16 @@ func populateIndex(t *testing.T, index *Index, vectorCount int) [][]float32 {
 		t.Fatalf("Failed to get dimensions: %v", err)
 	}
 
-    for i := 0; i < vectorCount; i++ {
-        vector := generateTestVector(dimensions)
-        vector[0] = float32(i) // Make each vector unique
-        vectors[i] = vector
+	for i := 0; i < vectorCount; i++ {
+		vector := generateTestVector(dimensions)
+		vector[0] = float32(i) // Make each vector unique
+		vectors[i] = vector
 
-        err = index.Add(Key(i), vector)
-        if err != nil {
-            t.Fatalf("Failed to add vector %d: %v", i, err)
-        }
-    }
+		err = index.Add(Key(i), vector)
+		if err != nil {
+			t.Fatalf("Failed to add vector %d: %v", i, err)
+		}
+	}
 	return vectors
 }
 
@@ -189,12 +189,12 @@ func TestBasicOperations(t *testing.T) {
 			t.Fatalf("Failed to reserve capacity: %v", err)
 		}
 
-        // Add a vector
-        vector := generateTestVector(defaultTestDimensions)
-        vector[0] = 42.0
-        vector[1] = 24.0
+		// Add a vector
+		vector := generateTestVector(defaultTestDimensions)
+		vector[0] = 42.0
+		vector[1] = 24.0
 
-        err := index.Add(100, vector)
+		err := index.Add(100, vector)
 		if err != nil {
 			t.Fatalf("Failed to add vector: %v", err)
 		}
@@ -524,13 +524,13 @@ func TestQuantizationTypes(t *testing.T) {
 		if err := index.Reserve(1); err != nil {
 			t.Fatalf("Failed to reserve capacity: %v", err)
 		}
-        vector := generateTestVector(32)
-        err := index.Add(1, vector)
+		vector := generateTestVector(32)
+		err := index.Add(1, vector)
 		if err != nil {
 			t.Fatalf("F32 Add failed: %v", err)
 		}
 
-        keys, _, err := index.Search(vector, 1)
+		keys, _, err := index.Search(vector, 1)
 		if err != nil {
 			t.Fatalf("F32 Search failed: %v", err)
 		}
@@ -551,17 +551,17 @@ func TestQuantizationTypes(t *testing.T) {
 		if err := index.Reserve(1); err != nil {
 			t.Fatalf("Failed to reserve capacity: %v", err)
 		}
-        vector := make([]float64, 32)
-        for i := range vector {
-            vector[i] = float64(i) + 0.5
-        }
+		vector := make([]float64, 32)
+		for i := range vector {
+			vector[i] = float64(i) + 0.5
+		}
 
-        err := index.AddUnsafe(1, unsafe.Pointer(&vector[0]))
+		err := index.AddUnsafe(1, unsafe.Pointer(&vector[0]))
 		if err != nil {
 			t.Fatalf("F64 AddUnsafe failed: %v", err)
 		}
 
-        keys, _, err := index.SearchUnsafe(unsafe.Pointer(&vector[0]), 1)
+		keys, _, err := index.SearchUnsafe(unsafe.Pointer(&vector[0]), 1)
 		if err != nil {
 			t.Fatalf("F64 SearchUnsafe failed: %v", err)
 		}
@@ -582,13 +582,13 @@ func TestQuantizationTypes(t *testing.T) {
 		if err := index.Reserve(1); err != nil {
 			t.Fatalf("Failed to reserve capacity: %v", err)
 		}
-        vector := generateTestVectorI8(32)
-        err := index.AddI8(1, vector)
+		vector := generateTestVectorI8(32)
+		err := index.AddI8(1, vector)
 		if err != nil {
 			t.Fatalf("I8 Add failed: %v", err)
 		}
 
-        keys, _, err := index.SearchI8(vector, 1)
+		keys, _, err := index.SearchI8(vector, 1)
 		if err != nil {
 			t.Fatalf("I8 Search failed: %v", err)
 		}
@@ -614,8 +614,8 @@ func TestUnsafeOperations(t *testing.T) {
 		if err := index.Reserve(1); err != nil {
 			t.Fatalf("Failed to reserve capacity: %v", err)
 		}
-        vector := generateTestVector(64)
-        ptr := unsafe.Pointer(&vector[0])
+		vector := generateTestVector(64)
+		ptr := unsafe.Pointer(&vector[0])
 
 		// Test AddUnsafe
 		err := index.AddUnsafe(100, ptr)
@@ -671,12 +671,12 @@ func TestConcurrentInsertions(t *testing.T) {
 		_ = index.ChangeThreadsAdd(uint(runtime.NumCPU()))
 
 		for i := 0; i < totalVectors; i++ {
-            vector := generateTestVector(64)
-            vector[0] = float32(i)
-            if err := index.Add(Key(i), vector); err != nil {
-                t.Fatalf("Insertion failed at %d: %v", i, err)
-            }
-        }
+			vector := generateTestVector(64)
+			vector[0] = float32(i)
+			if err := index.Add(Key(i), vector); err != nil {
+				t.Fatalf("Insertion failed at %d: %v", i, err)
+			}
+		}
 
 		// Verify final count
 		finalSize, err := index.Len()
@@ -763,17 +763,22 @@ func TestExactSearch(t *testing.T) {
 		const datasetSize = 100
 		const querySize = 10
 		const vectorDims = 32
+		const maxResults = 5
 
 		dataset := make([]float32, datasetSize*vectorDims)
 		queries := make([]float32, querySize*vectorDims)
 
 		// Fill with test data
-		for i := 0; i < len(dataset); i++ {
-			dataset[i] = float32(i%100) + 0.1
+		for i := 0; i < datasetSize; i++ {
+			for j := 0; j < vectorDims; j++ {
+				dataset[i*vectorDims+j] = float32(i%100+j) + 0.1
+			}
 		}
 
-		for i := 0; i < len(queries); i++ {
-			queries[i] = float32(i%50) + 0.1
+		for i := 0; i < querySize; i++ {
+			for j := 0; j < vectorDims; j++ {
+				queries[i*vectorDims+j] = float32(j%50) + 0.1
+			}
 		}
 
 		keys, distances, err := ExactSearch(
@@ -781,35 +786,47 @@ func TestExactSearch(t *testing.T) {
 			datasetSize, querySize,
 			vectorDims*4, vectorDims*4, // Stride in bytes for float32
 			vectorDims, Cosine,
-			5, 0, // maxResults=5, numThreads=0 (auto)
-			8, 4, // resultKeysStride, resultDistancesStride
+			maxResults, 0, // maxResults=5, numThreads=0 (auto)
 		)
 
 		if err != nil {
 			t.Fatalf("ExactSearch failed: %v", err)
 		}
 
-		if len(keys) != 5 || len(distances) != 5 {
-			t.Fatalf("Expected 5 results from ExactSearch, got %d keys and %d distances",
+		if len(keys) != maxResults*querySize || len(distances) != maxResults*querySize {
+			t.Fatalf("Expected 5*10 results from ExactSearch, got %d keys and %d distances",
 				len(keys), len(distances))
 		}
+
+		for i := 0; i < querySize; i++ {
+			for j := 0; j < maxResults; j++ {
+				if keys[j] != keys[i*maxResults+j] || distances[j] != distances[i*maxResults+j] {
+					t.Fatalf("Expected same results from ExactSearch for all keys and distances")
+				}
+			}
+		}
 	})
 
 	t.Run("I8 exact search", func(t *testing.T) {
 		const datasetSize = 50
 		const querySize = 5
 		const vectorDims = 16
+		const maxResults = 3
 
 		dataset := make([]int8, datasetSize*vectorDims)
 		queries := make([]int8, querySize*vectorDims)
 
 		// Fill with test data
-		for i := 0; i < len(dataset); i++ {
-			dataset[i] = int8((i % 100) + 1)
+		for i := 0; i < datasetSize; i++ {
+			for j := 0; j < vectorDims; j++ {
+				dataset[i*vectorDims+j] = int8(i%100+j) + 1
+			}
 		}
 
-		for i := 0; i < len(queries); i++ {
-			queries[i] = int8((i % 50) + 1)
+		for i := 0; i < querySize; i++ {
+			for j := 0; j < vectorDims; j++ {
+				queries[i*vectorDims+j] = int8(j%50) + 1
+			}
 		}
 
 		keys, distances, err := ExactSearchI8(
@@ -817,18 +834,25 @@ func TestExactSearch(t *testing.T) {
 			datasetSize, querySize,
 			vectorDims, vectorDims, // Stride in bytes for int8
 			vectorDims, L2sq,
-			3, 0, // maxResults=3, numThreads=0 (auto)
-			8, 4, // resultKeysStride, resultDistancesStride
+			maxResults, 0, // maxResults=3, numThreads=0 (auto)
 		)
 
 		if err != nil {
 			t.Fatalf("ExactSearchI8 failed: %v", err)
 		}
 
-		if len(keys) != 3 || len(distances) != 3 {
-			t.Fatalf("Expected 3 results from ExactSearchI8, got %d keys and %d distances",
+		if len(keys) != maxResults*querySize || len(distances) != maxResults*querySize {
+			t.Fatalf("Expected 3*querySize results from ExactSearchI8, got %d keys and %d distances",
 				len(keys), len(distances))
 		}
+
+		for i := 0; i < querySize; i++ {
+			for j := 0; j < maxResults; j++ {
+				if keys[j] != keys[i*maxResults+j] || distances[j] != distances[i*maxResults+j] {
+					t.Fatalf("Expected same results from ExactSearch for all keys and distances")
+				}
+			}
+		}
 	})
 }
 

commit 7685a67a214bb3e46a518831b09786a59ebb7803
Author: Ash Vardanian <1983160+ashvardanian@users.noreply.github.com>
Date:   Sun Nov 30 11:37:29 2025 +0000

    Make: Bump CI versions

diff --git a/.github/workflows/prerelease.yml b/.github/workflows/prerelease.yml
index 3f9e384..759f3a3 100644
--- a/.github/workflows/prerelease.yml
+++ b/.github/workflows/prerelease.yml
@@ -27,12 +27,12 @@ jobs:
     runs-on: ubuntu-24.04
     steps:
       - name: Checkout
-        uses: actions/checkout@v5
+        uses: actions/checkout@v6
         with:
           fetch-depth: 0
           persist-credentials: false
       - name: Run TinySemVer
-        uses: ashvardanian/tinysemver@v2.1.1
+        uses: ashvardanian/tinysemver@v3.0.0
         with:
           verbose: "true"
           version-file: "VERSION"
@@ -66,7 +66,7 @@ jobs:
 
     steps:
       - name: Checkout
-        uses: actions/checkout@v5
+        uses: actions/checkout@v6
       - name: Pull Git submodules
         run: git submodule update --init --recursive
 
@@ -98,7 +98,7 @@ jobs:
 
         # JavaScript
       - name: Set up Node.js
-        uses: actions/setup-node@v5
+        uses: actions/setup-node@v6
         with:
           node-version: ${{ env.NODE_VERSION }}
       - name: Install dependencies
@@ -163,7 +163,7 @@ jobs:
 
     steps:
       - name: Checkout
-        uses: actions/checkout@v5
+        uses: actions/checkout@v6
       - name: Pull Git submodules
         run: git submodule update --init --recursive
 
@@ -182,7 +182,7 @@ jobs:
 
         # JavaScript
       - name: Set up Node.js
-        uses: actions/setup-node@v5
+        uses: actions/setup-node@v6
         with:
           node-version: ${{ env.NODE_VERSION }}
       - name: Install dependencies
@@ -239,7 +239,7 @@ jobs:
 
     steps:
       - name: Checkout
-        uses: actions/checkout@v5
+        uses: actions/checkout@v6
       - name: Pull Git submodules
         run: git submodule update --init --recursive
 
@@ -257,7 +257,7 @@ jobs:
 
         # JavaScript
       - name: Set up Node.js
-        uses: actions/setup-node@v5
+        uses: actions/setup-node@v6
         with:
           node-version: ${{ env.NODE_VERSION }}
       - name: Install dependencies
@@ -318,7 +318,7 @@ jobs:
     runs-on: windows-2022
     steps:
       - name: Checkout
-        uses: actions/checkout@v5
+        uses: actions/checkout@v6
       - name: Pull Git submodules
         run: git submodule update --init --recursive
 
@@ -348,7 +348,7 @@ jobs:
 
         # JavaScript
       - name: Set up Node.js
-        uses: actions/setup-node@v5
+        uses: actions/setup-node@v6
         with:
           node-version: ${{ env.NODE_VERSION }}
       - name: Install dependencies
@@ -387,7 +387,7 @@ jobs:
     runs-on: windows-2022
     steps:
       - name: Checkout
-        uses: actions/checkout@v5
+        uses: actions/checkout@v6
       - name: Pull Git submodules
         run: git submodule update --init --recursive
 
@@ -411,7 +411,7 @@ jobs:
     runs-on: ubuntu-22.04
     steps:
       - name: Checkout
-        uses: actions/checkout@v5
+        uses: actions/checkout@v6
       - name: Pull Git submodules
         run: git submodule update --init --recursive
       - name: Build
@@ -438,7 +438,7 @@ jobs:
         python-version: ["38", "39", "310", "311", "312", "313", "313t"]
     steps:
       - name: Checkout
-        uses: actions/checkout@v5
+        uses: actions/checkout@v6
       - name: Set up Python
         uses: actions/setup-python@v6
         with:
@@ -477,7 +477,7 @@ jobs:
 
     steps:
       - name: Checkout
-        uses: actions/checkout@v5
+        uses: actions/checkout@v6
       - name: Pull Git submodules
         run: git submodule update --init --recursive
 
@@ -527,7 +527,7 @@ jobs:
             arch: arm64
     steps:
       - name: Checkout
-        uses: actions/checkout@v5
+        uses: actions/checkout@v6
       - name: Pull Git submodules
         run: git submodule update --init --recursive
 
@@ -599,7 +599,7 @@ jobs:
           zip -r usearch_android_${{ matrix.arch }}_${version}.zip build_artifacts/libusearch_c.so c/usearch.h
 
       - name: Upload Android libraries
-        uses: actions/upload-artifact@v4
+        uses: actions/upload-artifact@v5
         with:
           name: android-${{ matrix.abi }}-libraries
           path: usearch_android_*.zip
diff --git a/.github/workflows/release.yml b/.github/workflows/release.yml
index 82555e9..f2547e1 100644
--- a/.github/workflows/release.yml
+++ b/.github/workflows/release.yml
@@ -30,12 +30,12 @@ jobs:
     runs-on: ubuntu-latest
     steps:
       - name: Checkout
-        uses: actions/checkout@v5
+        uses: actions/checkout@v6
         with:
           fetch-depth: 0
           persist-credentials: false
       - name: Run TinySemVer
-        uses: ashvardanian/tinysemver@v2.1.1
+        uses: ashvardanian/tinysemver@v3.0.0
         with:
           verbose: "true"
           version-file: "VERSION"
@@ -69,7 +69,7 @@ jobs:
     runs-on: ubuntu-22.04
     steps:
       - name: Checkout the latest code
-        uses: actions/checkout@v5
+        uses: actions/checkout@v6
         with:
           fetch-depth: 0
 
@@ -109,7 +109,7 @@ jobs:
 
     steps:
       - name: Check out refreshed version
-        uses: actions/checkout@v5
+        uses: actions/checkout@v6
         with:
           ref: "main"
       - name: Pull Git submodules
@@ -156,7 +156,7 @@ jobs:
           dpkg-deb --build "usearch_linux_${{ matrix.arch }}_${{ steps.set_version.outputs.version }}"
 
       - name: Upload native library for Java
-        uses: actions/upload-artifact@v4
+        uses: actions/upload-artifact@v5
         with:
           name: native-libs-linux-${{ matrix.arch }}
           path: build_release/libusearch_c.so
@@ -180,7 +180,7 @@ jobs:
         arch: [x64, x86, arm64]
     steps:
       - name: Check out refreshed version
-        uses: actions/checkout@v5
+        uses: actions/checkout@v6
         with:
           ref: "main"
       - name: Pull Git submodules
@@ -190,7 +190,7 @@ jobs:
         uses: jwlawson/actions-setup-cmake@v2
 
       - name: Set up Go
-        uses: actions/setup-go@v5
+        uses: actions/setup-go@v6
         with:
           go-version: ${{ env.GO_VERSION }}
           cache: false
@@ -228,7 +228,7 @@ jobs:
           tar -cvf usearch_windows_${{ matrix.arch }}_${{ steps.set_version.outputs.version }}.tar .\build_release\libusearch_c.dll .\c\usearch.h
 
       - name: Upload native library for Java
-        uses: actions/upload-artifact@v4
+        uses: actions/upload-artifact@v5
         with:
           name: native-libs-windows-${{ matrix.arch }}
           path: build_release/libusearch_c.dll
@@ -252,14 +252,14 @@ jobs:
         arch: [arm64, x86_64]
     steps:
       - name: Check out refreshed version
-        uses: actions/checkout@v5
+        uses: actions/checkout@v6
         with:
           ref: "main"
       - name: Pull Git submodules
         run: git submodule update --init --recursive
 
       - name: Set up Go
-        uses: actions/setup-go@v5
+        uses: actions/setup-go@v6
         with:
           go-version: ${{ env.GO_VERSION }}
           cache: false
@@ -284,7 +284,7 @@ jobs:
           mv build_release/libusearch_sqlite.dylib usearch_sqlite_macos_${{ matrix.arch }}_${{ steps.set_version.outputs.version }}.dylib
 
       - name: Upload native library for Java
-        uses: actions/upload-artifact@v4
+        uses: actions/upload-artifact@v5
         with:
           name: native-libs-macos-${{ matrix.arch }}
           path: build_release/libusearch_c.dylib
@@ -325,7 +325,7 @@ jobs:
 
     steps:
       - name: Check out refreshed version
-        uses: actions/checkout@v5
+        uses: actions/checkout@v6
         with:
           ref: "main"
       - name: Pull Git submodules
@@ -359,7 +359,7 @@ jobs:
           zip -r usearch_android_${{ matrix.arch }}_${{ steps.set_version.outputs.version }}.zip build_artifacts/libusearch_c.so c/usearch.h
 
       - name: Upload native library for Java
-        uses: actions/upload-artifact@v4
+        uses: actions/upload-artifact@v5
         with:
           name: native-libs-android-${{ matrix.arch }}
           path: build_artifacts/libusearch_c.so
@@ -388,7 +388,7 @@ jobs:
 
     steps:
       - name: Check out refreshed version
-        uses: actions/checkout@v5
+        uses: actions/checkout@v6
         with:
           ref: "main"
       - name: Pull Git submodules
@@ -438,7 +438,7 @@ jobs:
           cmake --build build_artifacts --config Release -j
 
       - name: Upload JNI library artifact
-        uses: actions/upload-artifact@v4
+        uses: actions/upload-artifact@v5
         with:
           name: usearch-jni-linux-${{ matrix.arch }}
           path: build_artifacts/libusearch_jni.so
@@ -467,7 +467,7 @@ jobs:
 
     steps:
       - name: Check out refreshed version
-        uses: actions/checkout@v5
+        uses: actions/checkout@v6
         with:
           ref: "main"
       - name: Pull Git submodules
@@ -500,7 +500,7 @@ jobs:
           cmake --build build_artifacts --config Release
 
       - name: Upload JNI library artifact
-        uses: actions/upload-artifact@v4
+        uses: actions/upload-artifact@v5
         with:
           name: usearch-jni-windows-${{ matrix.arch }}
           path: build_artifacts/libusearch_jni.dll
@@ -521,7 +521,7 @@ jobs:
 
     steps:
       - name: Check out refreshed version
-        uses: actions/checkout@v5
+        uses: actions/checkout@v6
         with:
           ref: "main"
       - name: Pull Git submodules
@@ -554,7 +554,7 @@ jobs:
           cmake --build build_artifacts --config Release
 
       - name: Upload JNI library artifact
-        uses: actions/upload-artifact@v4
+        uses: actions/upload-artifact@v5
         with:
           name: usearch-jni-macos-${{ matrix.arch }}
           path: build_artifacts/libusearch_jni.dylib
@@ -577,7 +577,7 @@ jobs:
 
     steps:
       - name: Check out refreshed version
-        uses: actions/checkout@v5
+        uses: actions/checkout@v6
         with:
           ref: "main"
       - name: Pull Git submodules
@@ -616,7 +616,7 @@ jobs:
           cmake --build build_artifacts --config Release
 
       - name: Upload JNI library artifact
-        uses: actions/upload-artifact@v4
+        uses: actions/upload-artifact@v5
         with:
           name: usearch-jni-android-${{ matrix.arch }}
           path: build_artifacts/libusearch_jni.so
@@ -628,7 +628,7 @@ jobs:
     needs: versioning
     steps:
       - name: Check out refreshed version
-        uses: actions/checkout@v5
+        uses: actions/checkout@v6
         with:
           ref: "main"
       - name: Pull Git submodules
@@ -737,12 +737,12 @@ jobs:
         python-version: ["38", "39", "310", "311", "312", "313", "313t"]
     steps:
       - name: Check out refreshed version
-        uses: actions/checkout@v5
+        uses: actions/checkout@v6
         with:
           ref: "main"
       - name: Setup Docker
         if: matrix.os == 'ubuntu-24.04'
-        uses: crazy-max/ghaction-setup-docker@v3.4.0
+        uses: docker/setup-docker-action@v4
       - name: Set up Python
         uses: actions/setup-python@v6
         with:
@@ -759,7 +759,7 @@ jobs:
           CIBW_ENABLE: cpython-freethreading # No-GIL 3.13t builds
           CIBW_TEST_SKIP: "*-win_arm64" # Too complex to emulate Windows ARM
       - name: Upload wheels
-        uses: actions/upload-artifact@v4
+        uses: actions/upload-artifact@v5
         with:
           name: cibw-wheels-${{ matrix.os }}-${{ strategy.job-index }}
           path: ./wheelhouse/*.whl
@@ -777,7 +777,7 @@ jobs:
 
     steps:
       - name: Download artifacts
-        uses: actions/download-artifact@v4
+        uses: actions/download-artifact@v6
         with:
           # unpacks all CIBW artifacts into dist/
           pattern: cibw-*
@@ -813,14 +813,14 @@ jobs:
 
     steps:
       - name: Checkout the latest code
-        uses: actions/checkout@v5
+        uses: actions/checkout@v6
         with:
           ref: "main"
       - name: Pull Git submodules
         run: git submodule update --init --recursive
 
       - name: Set up Node.js
-        uses: actions/setup-node@v5
+        uses: actions/setup-node@v6
         with:
           node-version: ${{ env.NODE_VERSION }}
           architecture: ${{ matrix.arch }}
@@ -857,7 +857,7 @@ jobs:
           npm run prebuild-arm64
           aarch64-linux-gnu-strip prebuilds/linux-arm64/*node
       - name: Upload prebuilds
-        uses: actions/upload-artifact@v4
+        uses: actions/upload-artifact@v5
         with:
           name: prebuilds-${{ matrix.os }}-${{ matrix.arch }}
           path: prebuilds
@@ -870,19 +870,19 @@ jobs:
 
     steps:
       - name: Check out refreshed version
-        uses: actions/checkout@v5
+        uses: actions/checkout@v6
         with:
           ref: "main"
       - name: Pull Git submodules
         run: git submodule update --init --recursive
 
       - name: Set up Node.js
-        uses: actions/setup-node@v5
+        uses: actions/setup-node@v6
         with:
           node-version: ${{ env.NODE_VERSION }}
 
       - name: Download prebuilds
-        uses: actions/download-artifact@v4
+        uses: actions/download-artifact@v6
         with:
           pattern: prebuilds-*
           merge-multiple: true
@@ -917,7 +917,7 @@ jobs:
     runs-on: ubuntu-24.04
     steps:
       - name: Check out refreshed version
-        uses: actions/checkout@v5
+        uses: actions/checkout@v6
         with:
           ref: "main"
       - name: Pull Git submodules
@@ -956,14 +956,14 @@ jobs:
 
     steps:
       - name: Check out refreshed version
-        uses: actions/checkout@v5
+        uses: actions/checkout@v6
         with:
           ref: "main"
       - name: Pull Git submodules
         run: git submodule update --init --recursive
 
       - name: Download all JNI libraries
-        uses: actions/download-artifact@v4
+        uses: actions/download-artifact@v6
         with:
           pattern: usearch-jni-*
 
@@ -1047,7 +1047,7 @@ jobs:
     runs-on: macos-15
     steps:
       - name: Check out refreshed version
-        uses: actions/checkout@v5
+        uses: actions/checkout@v6
         with:
           ref: "main"
       - name: Pull Git submodules
@@ -1068,7 +1068,7 @@ jobs:
       packages: write
     steps:
       - name: Check out refreshed version
-        uses: actions/checkout@v5
+        uses: actions/checkout@v6
         with:
           ref: "main"
       - name: Pull Git submodules
@@ -1115,7 +1115,7 @@ jobs:
 
     steps:
       - name: Check out refreshed version
-        uses: actions/checkout@v5
+        uses: actions/checkout@v6
         with:
           ref: "main"
       - name: Pull Git submodules
@@ -1151,7 +1151,7 @@ jobs:
           cp "${{ github.workspace }}\build_artifacts\libusearch_c.dll" "${{ github.workspace }}\csharp\lib\runtimes\win-x64\native"
 
       - name: Upload Artifacts
-        uses: actions/upload-artifact@v4
+        uses: actions/upload-artifact@v5
         with:
           name: usearch-csharp-dependencies-${{ matrix.os }}
           path: ${{ github.workspace }}/csharp/lib/**/*
@@ -1169,14 +1169,14 @@ jobs:
       GITHUB_PACKAGES_SOURCE: https://nuget.pkg.github.com/${{ github.repository_owner }}/index.json
     steps:
       - name: Check out refreshed version
-        uses: actions/checkout@v5
+        uses: actions/checkout@v6
         with:
           ref: "main"
       - name: Pull Git submodules
         run: git submodule update --init --recursive
 
       - name: Download usearch libs artifact
-        uses: actions/download-artifact@v4
+        uses: actions/download-artifact@v6
         with:
           pattern: usearch-csharp-dependencies-*
           merge-multiple: true
@@ -1219,7 +1219,7 @@ jobs:
       contents: write
     steps:
       - name: Checkout
-        uses: actions/checkout@v5
+        uses: actions/checkout@v6
         with:
           ref: "main"
       - name: Install dependencies

commit 42ff4707b4dc3eb34ee763e591cf9ad4350fea7e
Author: Ash Vardanian <1983160+ashvardanian@users.noreply.github.com>
Date:   Sun Nov 30 11:20:01 2025 +0000

    Make: Wrong ISA extensions for Windows JNI builds

diff --git a/.github/workflows/release.yml b/.github/workflows/release.yml
index 14c0af2..82555e9 100644
--- a/.github/workflows/release.yml
+++ b/.github/workflows/release.yml
@@ -454,10 +454,16 @@ jobs:
         include:
           - arch: x64
             cmake_arch: x64
+            simsimd_target_x86: 1
+            simsimd_target_arm: 0
           - arch: x86
             cmake_arch: Win32
+            simsimd_target_x86: 1
+            simsimd_target_arm: 0
           - arch: arm64
             cmake_arch: ARM64
+            simsimd_target_x86: 0
+            simsimd_target_arm: 1
 
     steps:
       - name: Check out refreshed version
@@ -483,9 +489,10 @@ jobs:
             -DUSEARCH_BUILD_LIB_C=0 `
             -DUSEARCH_USE_FP16LIB=1 `
             -DUSEARCH_USE_SIMSIMD=1 `
-            -DSIMSIMD_TARGET_HASWELL=1 `
-            -DSIMSIMD_TARGET_SKYLAKE=1 `
-            -DSIMSIMD_TARGET_ICE=1 `
+            -DSIMSIMD_TARGET_NEON=${{ matrix.simsimd_target_arm }} `
+            -DSIMSIMD_TARGET_HASWELL=${{ matrix.simsimd_target_x86 }} `
+            -DSIMSIMD_TARGET_SKYLAKE=${{ matrix.simsimd_target_x86 }} `
+            -DSIMSIMD_TARGET_ICE=${{ matrix.simsimd_target_x86 }} `
             -DSIMSIMD_TARGET_GENOA=0 `
             -DSIMSIMD_TARGET_SAPPHIRE=0 `
             -DSIMSIMD_DYNAMIC_DISPATCH=1

commit a2f17599101729d667dc0260dd278852d9098183
Author: TinySemVer <tinysemver@ashvardanian.com>
Date:   Sun Nov 30 09:54:25 2025 +0000

    Release: v2.21.4 [skip ci]
    ### Patch
    
    - Fix: Progress callback passing & minor checks (c604a90)
    - Fix: Skip key rewrites in `index_gt::update` (#679) (6387134)
    - Fix: Correct conditional lock release w/out acquire (#681) (c001112)

diff --git a/CITATION.cff b/CITATION.cff
index 9fb57d3..e72352d 100644
--- a/CITATION.cff
+++ b/CITATION.cff
@@ -5,7 +5,7 @@ authors:
     given-names: "Ash"
     orcid: "https://orcid.org/0000-0002-4882-1815"
 title: "USearch by Unum Cloud"
-version: 2.21.3
+version: 2.21.4
 doi: 10.5281/zenodo.7949416
 date-released: 2023-10-22
 url: "https://github.com/unum-cloud/usearch"
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 1be6800..c3abac4 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -3,7 +3,7 @@
 cmake_minimum_required(VERSION 3.11 FATAL_ERROR)
 project(
     usearch
-    VERSION 2.21.3
+    VERSION 2.21.4
     LANGUAGES C CXX
     DESCRIPTION "Smaller & Faster Single-File Vector Search Engine from Unum"
     HOMEPAGE_URL "https://github.com/unum-cloud/usearch"
diff --git a/Cargo.lock b/Cargo.lock
index 9dc0a48..c13971a 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -364,7 +364,7 @@ checksum = "4a1a07cc7db3810833284e8d372ccdc6da29741639ecc70c9ec107df0fa6154c"
 
 [[package]]
 name = "usearch"
-version = "2.21.3"
+version = "2.21.4"
 dependencies = [
  "cxx",
  "cxx-build",
diff --git a/Cargo.toml b/Cargo.toml
index b928d4a..d288394 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -1,6 +1,6 @@
 [package]
 name = "usearch"
-version = "2.21.3"
+version = "2.21.4"
 authors = ["Ash Vardanian <1983160+ashvardanian@users.noreply.github.com>"]
 description = "Smaller & Faster Single-File Vector Search Engine from Unum"
 edition = "2021"
diff --git a/README.md b/README.md
index cbbb64b..93a178d 100644
--- a/README.md
+++ b/README.md
@@ -552,7 +552,7 @@ doi = {10.5281/zenodo.7949416},
 author = {Vardanian, Ash},
 title = {{USearch by Unum Cloud}},
 url = {https://github.com/unum-cloud/usearch},
-version = {2.21.3},
+version = {2.21.4},
 year = {2023},
 month = oct,
 }
diff --git a/VERSION b/VERSION
index e6cb6a1..2aed618 100644
--- a/VERSION
+++ b/VERSION
@@ -1 +1 @@
-2.21.3
+2.21.4
diff --git a/conanfile.py b/conanfile.py
index 332f000..798b9e8 100644
--- a/conanfile.py
+++ b/conanfile.py
@@ -7,7 +7,7 @@ required_conan_version = ">=1.53.0"
 class USearchConan(ConanFile):
 
     name = "usearch"
-    version = "2.21.3"
+    version = "2.21.4"
     license = "Apache-2.0"
     description = "Smaller & Faster Single-File Vector Search Engine from Unum"
     homepage = "https://github.com/unum-cloud/usearch"
diff --git a/csharp/nuget/nuget-package.props b/csharp/nuget/nuget-package.props
index 7693226..62f17fb 100644
--- a/csharp/nuget/nuget-package.props
+++ b/csharp/nuget/nuget-package.props
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Project>
   <PropertyGroup>
-    <Version Condition="'$(Version)' == ''">2.21.3</Version>
+    <Version Condition="'$(Version)' == ''">2.21.4</Version>
 
     <Authors>Unum</Authors>
     <Company>Unum</Company>
diff --git a/include/usearch/index.hpp b/include/usearch/index.hpp
index 52b1a2f..3a9d8a1 100644
--- a/include/usearch/index.hpp
+++ b/include/usearch/index.hpp
@@ -9,7 +9,7 @@
 
 #define USEARCH_VERSION_MAJOR 2
 #define USEARCH_VERSION_MINOR 21
-#define USEARCH_VERSION_PATCH 3
+#define USEARCH_VERSION_PATCH 4
 
 // Inferring C++ version
 // https://stackoverflow.com/a/61552074
diff --git a/java/README.md b/java/README.md
index 8e29bba..1f3cad1 100644
--- a/java/README.md
+++ b/java/README.md
@@ -19,7 +19,7 @@ repositories {
 // Task to download USearch JAR from GitHub releases
 task downloadUSearchJar {
     doLast {
-        def usearchVersion = '2.21.3'
+        def usearchVersion = '2.21.4'
         def usearchUrl = "https://github.com/unum-cloud/usearch/releases/download/v${usearchVersion}/usearch-${usearchVersion}.jar"
         def usearchFile = file("lib/usearch-${usearchVersion}.jar")
         
@@ -38,7 +38,7 @@ compileJava.dependsOn downloadUSearchJar
 
 dependencies {
     // USearch JAR from local lib directory (downloaded automatically)
-    implementation name: 'usearch', version: '2.21.3', ext: 'jar'
+    implementation name: 'usearch', version: '2.21.4', ext: 'jar'
 }
 ```
 
diff --git a/package-lock.json b/package-lock.json
index 81b5ff1..ce7e8a4 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -1,6 +1,6 @@
 {
     "name": "usearch",
-    "version": "2.21.3",
+    "version": "2.21.4",
     "lockfileVersion": 3,
     "requires": true,
     "packages": {
diff --git a/package.json b/package.json
index ab9b5f6..59cb3af 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
     "name": "usearch",
-    "version": "2.21.3",
+    "version": "2.21.4",
     "description": "Smaller & Faster Single-File Vector Search Engine from Unum",
     "author": "Ash Vardanian (https://ashvardanian.com/)",
     "license": "Apache 2.0",
diff --git a/wasmer.toml b/wasmer.toml
index 1bec8f5..c363c85 100644
--- a/wasmer.toml
+++ b/wasmer.toml
@@ -1,6 +1,6 @@
 [package]
 name = "unum/usearch"
-version = "2.21.3"
+version = "2.21.4"
 description = "Smaller & Faster Single-File Vector Search Engine from Unum"
 license = "Apache-2.0"
 readme = "README.md"

commit c604a903bc09362b7015e858a47da07af1bae7e8
Author: Ash Vardanian <1983160+ashvardanian@users.noreply.github.com>
Date:   Sun Nov 30 09:52:27 2025 +0000

    Fix: Progress callback passing & minor checks

diff --git a/include/usearch/index.hpp b/include/usearch/index.hpp
index dceb3db..52b1a2f 100644
--- a/include/usearch/index.hpp
+++ b/include/usearch/index.hpp
@@ -2624,7 +2624,10 @@ class index_gt {
         inline bool empty() const noexcept { return !count; }
         inline match_t operator[](std::size_t i) const noexcept { return at(i); }
         inline match_t front() const noexcept { return at(0); }
-        inline match_t back() const noexcept { return at(count - 1); }
+        inline match_t back() const noexcept {
+            usearch_assert_m(count > 0, "Can't call back() on an empty result set");
+            return at(count - 1);
+        }
         inline bool contains(vector_key_t key) const noexcept {
             for (std::size_t i = 0; i != count; ++i)
                 if (at(i).member.key == key)
@@ -4157,8 +4160,7 @@ class index_gt {
                 node_try_conditional_lock_(candidate_slot, updated_slot != candidate_slot, failed_to_acquire);
             if (failed_to_acquire)
                 continue;
-            auto optional_node_lock =
-                optional_node_lock_(candidate_slot, updated_slot == candidate_slot);
+            auto optional_node_lock = optional_node_lock_(candidate_slot, updated_slot == candidate_slot);
             neighbors_ref_t candidate_neighbors = neighbors_(candidate_ref, level);
 
             // Optional prefetching
diff --git a/package-lock.json b/package-lock.json
index 3352338..81b5ff1 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -6,7 +6,7 @@
     "packages": {
         "": {
             "name": "usearch",
-            "version": "2.20.6",
+            "version": "2.21.3",
             "hasInstallScript": true,
             "license": "Apache 2.0",
             "dependencies": {
diff --git a/python/usearch/index.py b/python/usearch/index.py
index 36e6acd..887bac2 100644
--- a/python/usearch/index.py
+++ b/python/usearch/index.py
@@ -210,6 +210,8 @@ def _search_in_compiled(
     ) -> Union[BatchMatches, Matches]:
         return batch_matches[0] if count_vectors == 1 else batch_matches
 
+    progress_callback = progress
+
     # Create progress bar if needed
     if log:
         name = log if isinstance(log, str) else "Search"
@@ -219,15 +221,24 @@ def _search_in_compiled(
             unit="vector",
         )
 
+        user_progress = progress
+
         def update_progress_bar(processed: int, total: int) -> bool:
             progress_bar.update(processed - progress_bar.n)
-            return progress if progress else True
+            if user_progress:
+                return user_progress(processed, total)
+            return True
 
-        tuple_ = compiled_callable(vectors, progress=update_progress_bar, **kwargs)
-        progress_bar.close()
+        progress_callback = update_progress_bar
+
+    if progress_callback:
+        tuple_ = compiled_callable(vectors, progress=progress_callback, **kwargs)
     else:
         tuple_ = compiled_callable(vectors, **kwargs)
 
+    if log:
+        progress_bar.close()
+
     return distill_batch(BatchMatches(*tuple_))
 
 
@@ -265,14 +276,14 @@ def _add_to_compiled(
     # Create progress bar if needed
     if log:
         name = log if isinstance(log, str) else "Add"
-        pbar = tqdm(
+        progress_bar = tqdm(
             desc=name,
             total=count_vectors,
             unit="vector",
         )
 
         def update_progress_bar(processed: int, total: int) -> bool:
-            pbar.update(processed - pbar.n)
+            progress_bar.update(processed - progress_bar.n)
             return progress(processed, total) if progress else True
 
         compiled.add_many(
@@ -282,7 +293,7 @@ def _add_to_compiled(
             threads=threads,
             progress=update_progress_bar,
         )
-        pbar.close()
+        progress_bar.close()
     else:
         compiled.add_many(keys, vectors, copy=copy, threads=threads, progress=progress)
 
@@ -367,7 +378,7 @@ class BatchMatches(Sequence):
             raise IndexError(f"`index` must be an integer under {len(self)}")
 
     def to_list(self) -> List[List[tuple]]:
-        """Convert the result for each query to the list of tuples with information about its matches."""
+        """Flatten matches for all queries into a list of `(key, distance)` tuples."""
         list_of_matches = [self.__getitem__(row) for row in range(self.__len__())]
         return [match.to_tuple() for matches in list_of_matches for match in matches]
 
@@ -420,9 +431,9 @@ class Clustering:
     def members_of(self, centroid: Key) -> np.ndarray:
         return self.queries[self.matches.keys.flatten() == centroid]
 
-    def subcluster(self, centroid: Key, **clustering_kwards) -> Clustering:
+    def subcluster(self, centroid: Key, **clustering_kwargs) -> Clustering:
         sub_keys = self.members_of(centroid)
-        return self.index.cluster(keys=sub_keys, **clustering_kwards)
+        return self.index.cluster(keys=sub_keys, **clustering_kwargs)
 
     def plot_centroids_popularity(self):
         from matplotlib import pyplot as plt

commit 6387134c4fbd8a98f53aa6d69d98cf83d0fec13b
Author: Yoonseok Kim <43584573+yoonseok-kim@users.noreply.github.com>
Date:   Sun Nov 30 18:24:17 2025 +0900

    Fix: Skip key rewrites in `index_gt::update` (#679)
    
    Relates to #678
    
    Co-authored-by: Yoonseok Kim <kys910524@gmail.com>

diff --git a/include/usearch/index.hpp b/include/usearch/index.hpp
index 2f49a39..dceb3db 100644
--- a/include/usearch/index.hpp
+++ b/include/usearch/index.hpp
@@ -2987,7 +2987,8 @@ class index_gt {
             }
             form_reverse_links_(metric, updated_slot, closest_view, value, level, context);
         }
-        updated_node.key(key);
+        if (static_cast<vector_key_t>(updated_node.key()) != key)
+            updated_node.key(key);
 
         // Normalize stats
         result.computed_distances = context.computed_distances - result.computed_distances;

commit c0011120aa8ca2ff90dc890bc972e490f0b52d85
Author: Yoonseok Kim <43584573+yoonseok-kim@users.noreply.github.com>
Date:   Sun Nov 30 18:23:10 2025 +0900

    Fix: Correct conditional lock release w/out acquire (#681)
    
    `index_gt::update` uses conditional `lock(node_try_conditional_lock_)` instead
    of the hard `lock(node_lock_)` that `index_gt::add` use. When `candidate_slot == updated_slot`,
    the function deliberately skips `atomic_set`, but it still returns a `node_conditional_lock_t`
    whose destructor unconditionally calls `atomic_reset`.
    
    Closes #680
    
    Co-authored-by: YoungHwi <orchistro@gmail.com>
    Co-authored-by: YoungHwi <1239809+orchistro@users.noreply.github.com>
    Co-authored-by: Yoonseok Kim <kys910524@gmail.com>

diff --git a/include/usearch/index.hpp b/include/usearch/index.hpp
index 05f55f0..2f49a39 100644
--- a/include/usearch/index.hpp
+++ b/include/usearch/index.hpp
@@ -3836,7 +3836,11 @@ class index_gt {
 
     inline node_conditional_lock_t node_try_conditional_lock_(std::size_t slot, bool condition,
                                                               bool& failed_to_acquire) const noexcept {
-        failed_to_acquire = condition ? nodes_mutexes_.atomic_set(slot) : false;
+        if (!condition) {
+            failed_to_acquire = false;
+            return {nodes_mutexes_, std::numeric_limits<std::size_t>::max()};
+        }
+        failed_to_acquire = nodes_mutexes_.atomic_set(slot);
         return {nodes_mutexes_, failed_to_acquire ? std::numeric_limits<std::size_t>::max() : slot};
     }
 
